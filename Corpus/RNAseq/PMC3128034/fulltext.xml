<!DOCTYPE article PUBLIC "-//NLM//DTD Journal Archiving and Interchange DTD v3.0 20080202//EN" "archivearticle3.dtd"> 
<article xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:mml="http://www.w3.org/1998/Math/MathML" article-type="research-article"><?DTDIdentifier.IdentifierValue article.dtd?><?DTDIdentifier.IdentifierType system?><?SourceDTD.DTDName article.dtd?><?SourceDTD.Version 1.0?><?ConverterInfo.XSLTName bmc2nlmx2.xsl?><?ConverterInfo.Version 2?><front><journal-meta><journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id><journal-title-group><journal-title>BMC Bioinformatics</journal-title></journal-title-group><issn pub-type="epub">1471-2105</issn><publisher><publisher-name>BioMed Central</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="pmcid">3128034</article-id><article-id pub-id-type="publisher-id">1471-2105-12-210</article-id><article-id pub-id-type="pmid">21615913</article-id><article-id pub-id-type="doi">10.1186/1471-2105-12-210</article-id><article-categories><subj-group subj-group-type="heading"><subject>Methodology Article</subject></subj-group></article-categories><title-group><article-title>A novel and well-defined benchmarking method for second generation read mapping</article-title></title-group><contrib-group><contrib contrib-type="author" corresp="yes" id="A1"><name><surname>Holtgrewe</surname><given-names>Manuel</given-names></name><xref ref-type="aff" rid="I1">1</xref><email>holtgrewe@inf.fu-berlin.de</email></contrib><contrib contrib-type="author" id="A2"><name><surname>Emde</surname><given-names>Anne-Katrin</given-names></name><xref ref-type="aff" rid="I1">1</xref><xref ref-type="aff" rid="I2">2</xref><email>emde@molgen.mpg.de</email></contrib><contrib contrib-type="author" id="A3"><name><surname>Weese</surname><given-names>David</given-names></name><xref ref-type="aff" rid="I1">1</xref><email>weese@inf.fu-berlin.de</email></contrib><contrib contrib-type="author" id="A4"><name><surname>Reinert</surname><given-names>Knut</given-names></name><xref ref-type="aff" rid="I1">1</xref><email>reinert@inf.fu-berlin.de</email></contrib></contrib-group><aff id="I1"><label>1</label>Department of Computer Science, Free University of Berlin, Takustr. 9, 14195 Berlin, Germany</aff><aff id="I2"><label>2</label>Max-Planck-Institute for Molecular Genetics, Ihnestr. 63-73, 14195 Berlin, Germany</aff><pub-date pub-type="collection"><year>2011</year></pub-date><pub-date pub-type="epub"><day>26</day><month>5</month><year>2011</year></pub-date><volume>12</volume><fpage>210</fpage><lpage>210</lpage><history><date date-type="received"><day>8</day><month>12</month><year>2010</year></date><date date-type="accepted"><day>26</day><month>5</month><year>2011</year></date></history><permissions><copyright-statement>Copyright &#x000a9;2011 Holtgrewe et al; licensee BioMed Central Ltd.</copyright-statement><copyright-year>2011</copyright-year><copyright-holder>Holtgrewe et al; licensee BioMed Central Ltd.</copyright-holder><license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/2.0"><license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/2.0">http://creativecommons.org/licenses/by/2.0</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p></license></permissions><self-uri xlink:href="http://www.biomedcentral.com/1471-2105/12/210"/><abstract><sec><title>Background</title><p>Second generation sequencing technologies yield DNA sequence data at ultra high-throughput. Common to most biological applications is a mapping of the reads to an almost identical or highly similar reference genome. The assessment of the quality of read mapping results is not straightforward and has not been formalized so far. Hence, it has not been easy to compare different read mapping approaches in a unified way and to determine which program is the best for what task.</p></sec><sec><title>Results</title><p>We present a new benchmark method, called Rabema (Read Alignment BEnchMArk), for read mappers. It consists of a strict definition of the read mapping problem and of tools to evaluate the result of arbitrary read mappers supporting the SAM output format.</p></sec><sec><title>Conclusions</title><p>We show the usefulness of the benchmark program by performing a comparison of popular read mappers. The tools supporting the benchmark are licensed under the GPL and available from <ext-link ext-link-type="uri" xlink:href="http://www.seqan.de/projects/rabema.html">http://www.seqan.de/projects/rabema.html</ext-link>.</p></sec></abstract></article-meta></front><body><sec><title>1 Background</title><p>Second generation (2G) sequencing technologies have many and diverse biological applications [<xref ref-type="bibr" rid="B1">1</xref>-<xref ref-type="bibr" rid="B7">7</xref>] and have effectively transformed the field of DNA sequence analysis. With the advances in sequencing technologies that continuously increase throughput at dramatically decreasing costs, also an increased demand for computationally efficient analysis tools has arisen. One of the most demanding but fundamental computational processing steps is read mapping, i.e. finding the positions of all sequenced reads in a reference genome. A variety of tools to solve the read mapping problem have been published, e.g. [<xref ref-type="bibr" rid="B8">8</xref>-<xref ref-type="bibr" rid="B12">12</xref>]. As read mapping is fundamental to all downstream analyses, the outcome of an analysis may differ significantly depending on the way reads were mapped. In addition, research in this field will remain active due to continuous progress in sequencing technology. Hence, the need for a careful and clear definition of the quality (resp. accuracy) of a read mapping result is apparent. Also, as the number of users of 2G sequencing machines and the number of read mapping tools for different purposes increase, it becomes crucial to be able to compare read mapping software to determine what tool is the best one for a specific purpose. Unfortunately, the various read mappers have different properties and use slightly different definitions of the read mapping problem which make such a comparison difficult.</p><p>Here, we will discuss and carefully define this problem, and point to the challenges that comprehensive and sensitive read mapping faces. Furthermore, we present a novel benchmark based on which the quality and speed of read mapping tools can be assessed. Our contribution consists of a <italic>precise definition </italic>of the read mapping problem and <italic>tools </italic>to evaluate the results of a read mapper. This enables the generation of gold standards for both simulated and real-world reads. It thus overcomes shortcomings when only using simulated reads, such as biases present in real data (cf. [<xref ref-type="bibr" rid="B13">13</xref>]). Using the four read mappers shown in Table S1 (supplementary tables, figures, and sections can be found in Additional File <xref ref-type="supplementary-material" rid="S1">1</xref>), we give an example of such an evaluation.</p><p>Besides helping to objectively compare programs, proper benchmarking has other merits, namely to kindle a keen competition among computer scientists. This often results in efficient algorithms and fast implementations. Examples are the RNASeq Genome Annotation Assessment Project [<xref ref-type="bibr" rid="B14">14</xref>] or the ENCODE Gene Prediction Workshop [<xref ref-type="bibr" rid="B15">15</xref>] which resulted in many new approaches to gene prediction and quantification.</p><p>Another advantage is better support for the algorithm engineering cycle [<xref ref-type="bibr" rid="B16">16</xref>]: First, an algorithm is designed and analyzed theoretically. This is followed by a careful implementation. The implementation is then experimentally evaluated and the theoretical hypotheses verified or discarded. Using this information, the next iteration in the cycle can be started.</p><p>Careful experimentation is one key aspect of a successful practical solution to algorithmic challenges. We expect that our benchmark method will help to advance read mapping research in the next years.</p></sec><sec><title>2 Methods</title><p>We use common notation from mathematics and computer science. We denote closed ends of an interval with square brackets and open ends of an interval with round brackets. For example, [<italic>a</italic>, <italic>b</italic>) is a half-open interval with the values from, and including, <italic>a </italic>up to, and excluding, <italic>b</italic>.</p><p>For a sequence <italic>S</italic>, <italic>S<sup>rc</sup></italic> gives the reverse-complement by reversing <italic>S </italic>and exchanging the characters with their complement. As usual, in DNA: C is exchanged with G and A with T.</p><sec><title>2.1 The Read Mapping Problem</title><p>An abstract definition of the read mapping problem can be given as follows. The input is a reference sequence <italic>S</italic>, a set <italic>R </italic>of reads <italic>r</italic>, a distance function <italic>&#x003b4; </italic>and a maximal distance <italic>k</italic>. <italic>&#x003b4; </italic>assigns a distance to semiglobal alignments of reads against <italic>S</italic>. The domain of <italic>&#x003b4; </italic>determines which alignments are possible, e.g. whether Hamming or edit distance is used. Note that <italic>&#x003b4; </italic>could also be the score of an alignment (e.g. a Smith-Waterman score), which we do not consider in this paper (see Section S3).</p><p>For each read <italic>r</italic>, the problem is to find a set of <italic>matches </italic>of <italic>r </italic>in <italic>S</italic>. The precise definition of the term <italic>match </italic>is suprisingly involved and will be given in Sections 2.2 to 2.4. For now, let a match be <italic>a location in the reference where the read aligns</italic>. A <italic>feasible </italic>match is a match where the read aligns with distance &#x02264; <italic>k</italic>. A <italic>best match </italic>is a feasible match that has the smallest distance of all feasible matches for the given read. We can rank the matches ascendingly by their distance. Now, let us consider the set of matches that is to be found. Obvious choices for the match set could be to find: (1) all feasible matches, (2) all best matches, (3) up to <italic>c </italic>best matches, or (4) up to <italic>c </italic>best-ranking matches. In this work, we consider (1-3), and (3) with <italic>c </italic>= 1, refered to as <italic>all, all-best</italic>, and <italic>any-best</italic>.</p><p>From the application of read mapping in biology, the <italic>biological problem </italic>arises. Here, the position in the reference should be found that corresponds to the sample position of each read. Because of ambiguities, this problem cannot be solved directly, but is approximated by the mathematical problem.</p></sec><sec><title>2.2 Defining Matches</title><p>In this section, we will try to give an intuition for the difficulties inherent in defining matches. These difficulties stem mostly from the problem of how to decide when two matches are <italic>different </italic>and when they should be considered the <italic>same</italic>. This will profoundly influence how we define a <italic>match </italic>and thus how we count correct matches.</p><p>First of all, we do not allow the first and last base of a read to align with a gap in the reference sequence. Such alignments are superfluous: Aligning the first/last base to the base at the left/right of the gap will always yield an alignment with a lower or equal distance. Figure S4 gives an example.</p><sec><title>When Are Two Matches Different?</title><p>When publishing their work, many authors of read mapping software simply count the number of mapped reads. This only allows for a crude assessment of read mappers relative to each other but not to the best possible solution.</p><p>Additionally, special care has to be taken when considering uniquely matching reads: If the read mapper does not have full sensitivity, it could miss a second match of a read and report it as unique match. Another read mapper could find both matches and discard the read as non-uniquely matching. In this case, a less sensitive read mapper could get a higher rating. Thus, one would also have to compare the non-uniquely matching reads as found by a read mapper to the ones reported as uniquely matching and compute a set of reads that are false positives. This is rarely, if ever, done in the literature, though. Note that this set of false positives can only be seen as an approximation if no read mapper with full sensitivity is included in the comparison. Additionally, a definition of "full sensitivity," i.e. of a gold standard is still required. Consider the read and reference sequence fragments from Figure <xref ref-type="fig" rid="F1">1</xref>. Say, we want to find the best two matches of the read in the reference sequence, with an edit distance of up to 3. Both with an edit distance of up to 3. Both localocations in the reference sequence are shown. The row <italic>alignments </italic>shows two alignments of the read to the reference sequence that appear to be "natural." However, the alignments in rows &#x022c6; and &#x022c6;&#x022c6; have a lower edit distance than the right one. Common sense would tell us that the alignments in the left column are not "significantly different," though. Each alignment with distance <italic>k </italic>induces alignments with distance at most <italic>k </italic>+ 2 by aligning the leftmost/rightmost base one more position to the left/right and introducing a gap. Repeats are another issue. Consider the tandem repeat in Figure <xref ref-type="fig" rid="F2">2(a)</xref>. Intuitively, we can identify the two distinct alignments shown there. Figure <xref ref-type="fig" rid="F2">2(b)</xref> shows another tandem repeat of shorter period with a read that aligns in this repeat region. Searching for alignments in Figure <xref ref-type="fig" rid="F2">2(b)</xref> in the same way as in Figure <xref ref-type="fig" rid="F2">2(a)</xref>), we could identify all alignments given in this figure.</p><fig id="F1" position="float"><label>Figure 1</label><caption><p><bold>Alignments of the read TCCCAAC against two locations in the reference sequence</bold>.</p></caption><graphic xlink:href="1471-2105-12-210-1"/></fig><fig id="F2" position="float"><label>Figure 2</label><caption><p><bold>Two examples for reads mapping in a long (a) and in a short (b) tandem repeat</bold>.</p></caption><graphic xlink:href="1471-2105-12-210-2"/></fig><p>However, counting alignments in this way would require a read mapper to find lots of positions in repeat regions. This is not desirable since reads from long tandem repeat regions would get a higher weight with this counting scheme than reads from short tandem repeat regions or reads from non-repeat regions. Only weighting each found match with <sup>1</sup>/<italic><sub>n</sub></italic> (where n is the number of positions the read aligns at) is deficient, too. It would be preferable to find a way to naturally <italic>merge similar matches </italic>(e.g. the one from the left column of Figure <xref ref-type="fig" rid="F1">1</xref>), matches that are very close to each other (c.f. Figure <xref ref-type="fig" rid="F2">2(b)</xref>) and to <italic>separate matches that are sufficiently distinct </italic>(c.f. Figure <xref ref-type="fig" rid="F2">2(a)</xref>).</p><p>To give a clear description on how to separate matches, we will first introduce <italic>trace trees</italic>.</p></sec><sec><title>Trace Trees</title><p>Consider a dynamic programming matrix for semi-global alignment (cf. [<xref ref-type="bibr" rid="B17">17</xref>]). Each alignment is represented by a path from the top row to the bottom row. Horizontal and vertical movements between cells represent indels, diagonal movements matches and mismatches.</p><p>Standard DP alignment algorithms yield the smallest distance for each alignment end position. From an end position, we can search for start positions by performing a traceback search backwards/upwards in the matrix. Given a value for <italic>k</italic>, we can find all start positions for the given end position that yield alignments with distance &#x02264; <italic>k</italic>. The backward search yields a path through the matrix which we call <italic>trace</italic>.</p><p>Note that we only consider DP algorithms that are deterministic and always perform the same choice in case of ambiguities. For example, if they have the choice between tracing back vertically, diagonally, and/or horizontally, they could always take the rightmost choice. In this case, they would prefer vertical over diagonal, diagonal over horizontal movement. Needleman-Wunsch is one example of such an algorithm. When plotting the traces for all feasible matches, we could get an image like the one shown in Figure <xref ref-type="fig" rid="F3">3</xref> (The numbers below the lower leafs in Figure <xref ref-type="fig" rid="F3">3</xref> give the minimal distance for the best alignments ending in this position): We can consider the traces as graphs where cells correspond to nodes and movements in a trace between cells can be seen as edges. The resulting graphs have some simple properties, namely that a) the graph decomposes into connected components and b) each connected component is a tree. If one chooses any vertex on the trace shared by all alignments as a root, then the resulting rooted tree is split into an upper and a lower part. The upper leafs correspond to possible start positions of alignments, the lower leafs correspond to possible end positions. Each combination of one upper and one lower leaf corresponds to a specific (although not necessarily feasible) alignment and is thus an upper bound on the number of feasible alignments.</p><fig id="F3" position="float"><label>Figure 3</label><caption><p><bold>This figure shows two neighbouring trace trees</bold>.</p></caption><graphic xlink:href="1471-2105-12-210-3"/></fig></sec><sec><title>Hamming Distance Matches</title><p>If we want to count all possible alignments, we note that each match in the Hamming distance model corresponds to exactly one diagonal in the matrix, namely the one between the start and end position of the match. Thus, we can define a match with Hamming distance simply with either its start or end position. For consistency with our choice for edit distance (see below), we pick the end position.</p></sec><sec><title>Redundant Edit Distance Matches</title><p>Considering all combinations of start and end positions is not desirable for edit distance: In Figure <xref ref-type="fig" rid="F3">3</xref>, there would be 4 &#x000d7; 6 = 24 such matches in the left tree alone, possibly many feasible ones. We have to resort to other means for counting alignments in the case of edit distance.</p></sec><sec><title>Identify Matches With End Position</title><p>We observe that the shared trace is usually longer than the branching parts. This means that large parts of the alignment are basically the same and even differing alignments might have the same distance. To avoid counting these as separate alignments, we proceed as follows.</p><p>We identify each match with its end position <italic>e </italic>and use the leftmost start position <italic>s </italic>with minimal distance as its <italic>canonical </italic>start position. The choice of <italic>s </italic>as the canonical start position is arbitrary. However, picking the leftmost position as <italic>s </italic>has the advantage that the interval between <italic>s </italic>and <italic>e </italic>contains the start position of all alignments of minimal score ending in <italic>e</italic>. In the example from Figure <xref ref-type="fig" rid="F3">3</xref>, this reduces the number of matches for the right tree from 24 to 6.</p></sec></sec><sec><title>2.3 Error Landscapes</title><p>In this section, we define <italic>error landscapes </italic>in order to capture the intuition of the match definition we will give in Section 2.4 more formally. The distance <italic>&#x003b4;</italic>(<italic>i</italic>) of a read to the genome at position <italic>i </italic>is the distance of the best alignment that ends there. If we plot the points (<italic>i</italic>, <italic>&#x003b4; </italic>(<italic>i</italic>)) for each reference sequence position <italic>i </italic>and connect them, we get an error landscape such as the one shown in Figure <xref ref-type="fig" rid="F4">4(a)</xref>. In this landscape, valleys represent regions where the read aligns with a low distance and mountains represent regions where the read aligns with a high distance.</p><fig id="F4" position="float"><label>Figure 4</label><caption><p><bold>This figure gives an example of the error landscape: (a) shows the landscape before smoothing and (b) shows it after smoothing and with water</bold>. The end position is plotted on the x axis, the distance is plotted on the y axis. In (a), the raised ground water is shown and the separating position has been smoothed. The point between the lines marked in red is a separating position (see Definition 3).</p></caption><graphic xlink:href="1471-2105-12-210-4"/></fig><p>Now, we let imaginary ground water in our landscape rise to a level of <italic>k </italic>+ 0.5. This is shown in Figure <xref ref-type="fig" rid="F4">4(b)</xref>. In this example, this yields five lakes. Each lake represents a class of matches with sufficiently low distance. The metaphor of the landscape with lakes corresponds to the natural merging of similar matches.</p><p>We expect a read mapper to locate each of these classes but it suffices to find one representantive in each class for the <italic>all </italic>variant. For criteria <italic>all-best </italic>and <italic>any-best</italic>, each lake is assigned the distance of the point with the lowest distance of all contained points. Put differently, each lake is assigned its depth &#x02013; if we stay in the metaphor of landscapes and lakes.</p></sec><sec><title>2.4 Matches as Equivalence Classes</title><p>After arguing, which matches should be considered the same and which different, we need to formalize this notion. Hence, the aim of this section is to give a strict mathematical definition for the term <italic>match </italic>such that it closely models the intuitions from Sections 2.2 and 2.3.</p><p>In Section 2.2, we already argued that we want to identify each match with its end position. We also enforce the alignment of the last read and reference bases as described there. Now, we want to find an equivalence relation that partitions the set of feasible matches in a sensible way such that each class corresponds to an intuitive match.</p><p>We will do this by defining an equivalence relation for merging neighbouring matches and then defining another one that merges separated feasible matches sharing the same trace. For numbers <italic>a</italic>, <italic>b </italic>in the following, we assume w.l.o.g. that <italic>a </italic>&#x02264; <italic>b</italic>. Also, we identify matches with their end position and use the two terms match and end position interchangeably.</p><p><bold>Definition 1 </bold>(Neighbour Equivalence). <italic>Two feasible matches (identified by their end positions) a, b are </italic>neighbour equivalent <inline-formula><inline-graphic xlink:href="1471-2105-12-210-i1.gif"/></inline-formula><italic> if for all x, a </italic>&#x02264; <italic>x </italic>&#x02264; <italic>b the following holds: &#x003b4;</italic>(<italic>x</italic>) &#x02264; <italic>k</italic>.</p><p><bold>Definition 2 </bold>(Trace Equivalence). <italic>Two matches a</italic>, <italic>b are </italic>trace equivalent <inline-formula><inline-graphic xlink:href="1471-2105-12-210-i2.gif"/></inline-formula><italic>if their traces share a part. This is the case if their canonical start position is equal</italic>.</p><p>For example, for <italic>k </italic>= 4, the last match ending in the rightmost leaf of the left tree and the leftmost leaf of the right tree in Figure <xref ref-type="fig" rid="F3">3</xref> are neighbour equivalent but not trace equivalent. However, the matches ending at the third and fourth leaf of Figure <xref ref-type="fig" rid="F3">3</xref> are trace equivalent but not neighbour equivalent.</p><p><bold>Definition 3 </bold>(<italic>k</italic>-Trace Equivalence). <italic>Two matches a, b are k</italic>-trace equivalent <inline-formula><inline-graphic xlink:href="1471-2105-12-210-i3.gif"/></inline-formula><italic>if one of the following holds: (1) They are feasible, neighbour equivalent, and trace equivalent. (2) There exist feasible, trace-equivalent matches &#x003b1;, &#x003b2; and a separating match &#x003b6; such that &#x003b1; </italic>&#x02264; <italic>a </italic>&#x02264; <italic>&#x003b6; </italic>&#x02264; <italic>b </italic>&#x02264; <italic>&#x003b2;</italic>.</p><p><italic>A </italic>separating match <italic>&#x003b6; is a match with &#x003b4; </italic>(<italic>&#x003b6;</italic>) <italic>&#x0003e; k and there exists &#x003b1;, &#x003b2;, &#x003b1; </italic>&#x0003c;<italic>&#x003b6; </italic>&#x0003c;<italic>&#x003b2; such that &#x003b4; </italic>(<italic>&#x003b1;</italic>), <italic>&#x003b4; </italic>(<italic>&#x003b2;</italic>) &#x02264; <italic>k</italic>.</p><p>Obviously, <inline-formula><inline-graphic xlink:href="1471-2105-12-210-i4.gif"/></inline-formula> and <inline-formula><inline-graphic xlink:href="1471-2105-12-210-i5.gif"/></inline-formula> are equivalence relations. Also, it is easy to see that <inline-formula><inline-graphic xlink:href="1471-2105-12-210-i6.gif"/></inline-formula> is reflexive, symmetric and transitive and thus an equivalence relation. We now define two matches <italic>a</italic>, <italic>b </italic>to be equivalent (<italic>a </italic>&#x02261; <italic>b</italic>) if they are <italic>k</italic>-trace equivalent or neighbour equivalent. The disjunction of two equivalence relations yields another equivalence relation.</p><p>It follows that &#x02261; gives a well-defined partition of the feasible matches which corresponds to the intuitions given in Section 2.3.</p></sec><sec><title>2.5 Gold Standard and Evaluation</title><p>Following the definition of <italic>k</italic>-trace equivalence, each equivalence class is an interval. The reference data set (<italic>gold standard</italic>) can thus be described as an array of triples (<italic>k</italic>, <italic>first</italic>, <italic>last</italic>) describing all intervals of feasible matches [<italic>first</italic>, <italic>last</italic>] for a given <italic>k </italic>for each read.</p><p>Given the gold standard and the result of a read mapper, the quantitative evaluation of the read mapper result is easy. In the evaluation, a specific value is selected for <italic>k</italic>, say <italic>c</italic>. Now, all intervals from the gold standard are selected, where the value of <italic>k </italic>equals <italic>c</italic>. After sorting these intervals, binary search can be used to check which equivalence classes were found by the read mapper.</p><p>An additional preprocessing step has to be done in the case of <italic>all-best </italic>and <italic>any-best </italic>evaluations. Here, we update the value of <italic>k </italic>in each interval <italic>I </italic>in the gold standard to the smallest value of <italic>k </italic>for all intervals contained in <italic>I</italic>. This is done before the selection step described in the above paragraph.</p><p>Further technical issues are described in Section S1.</p></sec><sec><title>2.6 Building the Gold Standard</title><p>We differentiate between building the gold standard for the biological problem and the mathematical problem.</p><sec><title>Biological Problem</title><p>Since it is not possible to observe the sequencing process at the molecular level, we use simulated reads. Note that simulation data always has certain shortcomings, as biases present in real biological data are hard to simulate. Such biases in short read sequencing data have been reported e.g. in [<xref ref-type="bibr" rid="B13">13</xref>]. Nevertheless, simulated data can be informative in benchmarking tools, and can therefore be used to complement real-world data.</p><p>From our simulation, we obtain read sequences together with their actual sample positions. Each of these positions is a representative of the one equivalence class the read mapper should find. Given this representative, the whole equivalence class (i.e. interval) can be found as described below for the mathematical problem. This procedure is, in essence, similar to simulating reads and checking whether their mapping position is close to the actual sample position, but has the advantage of not having to choose a cutoff for what is defined as "close". With our definition, the genomic sequence itself defines how far away from the originally simulated position a read may map in order to be counted as correct. Intervals in ambiguously mappable regions will be broader, while intervals in unambiguous regions will be tight.</p></sec><sec><title>Mathematical Problem</title><p>A na&#x000ef;ve solution for generating a gold standard for the mathematical problem is to use an online multiple string search algorithm and then merge the matches, according to &#x02261;. However, this is too slow even for moderate genome sizes.</p><p>A more sophisticated method is to take the matches of a read mapper with full sensitivity as the input. This will yield at least one match <italic>m </italic>in each equivalence class. Using <italic>m </italic>as seed, we can then reconstruct the interval around it and only have to look at a fraction of the reference sequence.</p><p>Starting from each <italic>m</italic>, we first extend the interval to the right. We extend until we find a match that has score &#x0003e;<italic>k </italic>and no match right of it with score &#x02264; <italic>k </italic>that has the same begin position. Analogously, we extend the interval to the left.</p><p>Finding the end and begin positions of the alignments can be efficiently implemented with approximate string search algorithms for Hamming and edit distance. For edit distance, we use Myers' bit vector algorithm [<xref ref-type="bibr" rid="B18">18</xref>], for Hamming distance we use a na&#x000ef;ve implementation.</p><p>Given <italic>k<sub>max</sub></italic>, a maximal value for <italic>k</italic>, we compute the gold standard for all 0 &#x02264; <italic>k </italic>&#x02264; <italic>k<sub>max</sub></italic> for each read.</p></sec></sec><sec><title>2.7 Read Mapping and Similar Problems</title><p>The mathematical objective of read mapping may vary for different types of biological analyses. For example, when mapping RNA-Seq reads onto a genomic sequence, one should consider that reads will span exon-exon boundaries. Here, a spliced mapping approach would be a reasonable choice.</p><p>The benchmarking method that we describe here considers the "core" read mapping problem, and evaluates how far a read mapper is away from the mathematically optimal solution. We do not address related problems such as spliced read mapping or multi-read assignment. We only consider pairwise alignments for individual reads using the popular and parameter free distance measures Hamming and Levenshtein distance.</p><p>Still, being able to measure how sensitively a read mapper detects all (best) mapping positions is indirectly useful for multi-read assignment: If a read mapper misses a high number of mapping locations, a subsequent multi-read assignment step is less likely to find the correct assignment.</p></sec><sec><title>2.8 Practical Considerations</title><p>The description above is simplified in some parts to ease the understanding. In practice, there are the following differences and additional considerations:</p><p>We always used absolute error values in our descriptions which is appropriate for reads of the same length. However, some technologies, e.g. 454 pyrosequencing, yield reads of varying length. Thus, we use error rates, which are relative to the read length.</p><p>Gold standards could be built from any read mapper with full sensitivity, e.g. Mrsfast [<xref ref-type="bibr" rid="B19">19</xref>] or Razers [<xref ref-type="bibr" rid="B12">12</xref>]. Razers supports both Hamming and edit distance for arbitrary read length whereas Mrsfast only supports Hamming distance. Of course, also tools that claim 100% sensitivity may contain bugs; RazerS is our in-house tool that we can correct quickly in case of problems. Therefore, we chose Razers for building gold standards.</p></sec><sec><title>2.9 Read Simulation</title><p>For our benchmark, we use the Mason read simulator [<xref ref-type="bibr" rid="B20">20</xref>]. The program takes a FASTA genome reference sequence <italic>S </italic>for its input. It then simulates an arbitrary number of haplotypes by adding indels and mismatches to <italic>S</italic>. Third, it simulates read sampling from the haplotypes, depending on the sequencing technology. Finally, it writes out the reads in FASTQ files and also creates a SAM file that describes the gold standard for the biological problem from Section 2.1.</p><p>Details can be found in Section S2.</p></sec></sec><sec><title>3 Results and Discussion</title><sec><title>3.1 Read Mapper Comparison</title><p>We have evaluated the read mappers Bowtie [<xref ref-type="bibr" rid="B11">11</xref>], Bwa [<xref ref-type="bibr" rid="B9">9</xref>], Shrimp2 [<xref ref-type="bibr" rid="B10">10</xref>], and Soap2 [<xref ref-type="bibr" rid="B8">8</xref>] on read sets for D. melanogaster and S. cerivisae from the Short Read Archive (SRA). Information about the read sets can be found in Table S2, Table S3 shows information regarding the used reference sequences. The gold standard for the mathematical problem from Section 2.1 was built with an error rate of 8% and edit distance. Also, we generated simulated read datasets for the evaluation of the biological problem from Section 2.1.</p><p>We used default parameters for Bwa as advised by the author; Illumina reads were mapped using the commands <italic>aln, samse</italic>, and <italic>sampe</italic>, 454 reads were mapped using <italic>bwasw</italic>. For Shrimp2, weighted seeds were used to improve performance for longer reads, as suggested by the authors. For Soap2 and Bowtie, we performed some initial benchmarks to optimize sensitivity, at the cost of a higher running time. These programs were also run with default paramters, the variants with tuned parameters are labeled Soap2 and <italic>Bowtie*</italic>. For parametrization details, see Section S4.</p><p>We limited the output of each read mapper to 100 alignments per read, where possible, to 1 for simulated reads. There is no option to limit the output of Soap2 to a certain number of alignments per read. For the evaluation, we perform a postprocessing step and only select the best 100 matches by edit distance, breaking ties randomly.</p><p>The experiments were performed on a computer with Linux 2.6.30, Intel Xeon processors with 2.67 Ghz and 76 GB of main memory. No program was run with more than one process/thread. Memory consumption was measured by parsing the output of the Unix command top every second. Table S4 shows the resource consumption for building the indices of Bowtie, Bwa and Soap2.</p><p>As a sanity check of the method, we also ran Razers with default parameters on all read sets. The expectation was that it should find nearly all intervals since it uses the same definition of the read mapping problem as the read mapping benchmark. Full sensitivity should only be limited by (1) reads with more than 100 matches, (2) the default sensitivity of 99%, and (3) its default error rate of 8% which might make it join lakes that are separated when analyzing with a lower error rate. The running time was expected to be generally lower than that of Shrimp and higher than that of index-based tools. This expectation was fulfilled and subsequently, Razers was excluded in the following evaluation. Plots and data that also show the performance, as well as the running times of Razers are available from the project homepage.</p><p>The metric <italic>normalized found intervals </italic>is defined as follows: Each read gives at most one point. If a read matches at <italic>n </italic>locations (i.e. intervals), each found location gives <sup>1</sup>/<italic>n </italic>point. To get percentages, the number of achieved points is divided by the number of reads and multiplied by 100. In the following, we will use the terms <italic>sensitivity </italic>and normalized found intervals interchangeably.</p><sec><title>Real-World Data</title><p>Figure <xref ref-type="fig" rid="F5">5</xref> shows the evaluation of normalized found intervals (aiming to find <italic>all </italic>and <italic>any-best </italic>intervals) over a varying error rate using different read sets for D. melanogaster. The plots are for 10,000 uniformly sampled reads from each read set. The read sets' SRA accession numbers are given in the caption of each plot. Table S5 shows the running time and memory consumption of the programs on these read sets. Here, we want to focus on the evaluation of sensitivity. Bowtie was not run on 454 reads because its lack of support for gaps practically makes it inapplicable to the indel-error prone 454 reads. Likewise, we did not process 454 reads with Soap2 since we were not able to obtain suitable parameters.</p><fig id="F5" position="float"><label>Figure 5</label><caption><p><bold>Normalized found intervals (percentage, categories <italic>all</italic>/<italic>any-best</italic>) for different programs on reads from fly</bold>. The gold standard was generated with an error rate of 8% and edit distance. The programs were run with default parameters, the x axis shows the variation of error rate in the evaluation. Read set properties are as follows. [EMBL: <ext-link ext-link-type="gen" xlink:href="SRR034673">SRR034673</ext-link>]: 454 reads, average length 273 bp; [EMBL: <ext-link ext-link-type="gen" xlink:href="SRR026674">SRR026674</ext-link>]: Illumina reads, 36 bp; [EMBL: <ext-link ext-link-type="gen" xlink:href="SRR049254">SRR049254</ext-link>]: Illumina reads, 100 bp. The key is the same for all plots. Note the different axis scalings.</p></caption><graphic xlink:href="1471-2105-12-210-5"/></fig><p>Figures <xref ref-type="fig" rid="F5">5(a)</xref> and <xref ref-type="fig" rid="F5">5(c)</xref> show the sensitivity results for the <italic>all </italic>problem on Illumina reads. Bowtie* and Shrimp2 are the most sensitive tools; while all tools' performances suffer from increasing error rates, Shrimp2 achieves the highest sensitivities at high error rates where the absolute number of errors is greater than 3. Soap2 and Bowtie, especially in their default versions, seem to be tuned toward low numbers of errors. The effect can be seen on long reads in Figure <xref ref-type="fig" rid="F5">5(c)</xref>: Using default settings, both tools' sensitivities drop dramatically for reads with more than 2 errors. The optimization of parameter settings for Soap2 and Bowtie clearly improves performance on long Illumina reads. For high error rates, this improvement even leads to 10 percentage points more sensitivity. For the short reads in Figure <xref ref-type="fig" rid="F5">5(a)</xref>, Bowtie's default already constitutes the optimal parameter setting; the lines for Bowtie* and Bowtie are therefore the same here. From Figures <xref ref-type="fig" rid="F5">5(a)</xref> and <xref ref-type="fig" rid="F5">5(c</xref>), we also see that Bwa does not perform very well in the <italic>all </italic>category. It is consistently about 2-3 percentage points behind Bowtie*. This is explained by the fact that Bwa only reports a single match for reads that exceed the number of matches to report (in our case 100).</p><p>Looking at the results for Illumina reads in the <italic>any-best </italic>category shown in Figures <xref ref-type="fig" rid="F5">5(b)</xref> and <xref ref-type="fig" rid="F5">5(d)</xref>, we see that Bwa is the best performing tool for this case. This holds for long and short reads, and for all investigated error rates. For short reads, both versions of Soap2 and of Bowtie perform equally well. As they are fully sensitive for reporting at least one best Hamming match for each read, their sensitivity only drops here due to missed gapped alignments. As can be seen for long reads, an absolute number of errors greater than 2, again leads to an increase in missed matches for the default versions of Soap2 and Bowtie. While Shrimp2 performs very well at the <italic>all </italic>problem, in the <italic>any-best </italic>criterium it lags behind all other tools (with exception of the non-optimized default of Soap2 and also Bowtie's default at high error rate). Due to the limitations mentioned above, only Bwa and Shrimp are shown in Figures <xref ref-type="fig" rid="F5">5(e)</xref> and <xref ref-type="fig" rid="F5">5(f)</xref>. For the long 454 reads, there usually exists only one or few mapping locations per read. Therefore, differences in sensitivities between the <italic>all </italic>and the <italic>any-best </italic>category are not as pronounced as for the shorter, more ambiguously mapping Illumina reads. Here, Shrimp2 consistently has a lead of 10-20 percentage points over Bwa. This higher sensitivity comes at the cost of one order of magnitude higher running time and memory consumption.</p><p>We conclude from our analysis that Shrimp2 is a highly sensitive tool for detecing multiple matches (category <italic>all</italic>). Thus, it appears to be a good choice for analyses that require high sensitivity. Also, Bwa is a very diverse tool and shows especially good performance for the practically relevant <italic>any-best </italic>problem. Apparently, Bowtie and Soap are geared towards fast short read mapping with low error rates. In the <italic>any-best </italic>category they find matches of short reads with high sensitivity.</p><p>For all tools, parametrization becomes increasingly important with increasing read lengths and increasing numbers of errors. Different parameter settings for the same tool can lead to discrepancies in sensitivity of more than 20 percentage points. This emphasizes the importance of a benchmark such as the one presented in this article which can be used by developers and users alike to test tools with different parametrizations. Figures S6 and S7 show the same evaluation for the data on reads from S. cerivisiae. (Note that tests were only performed on Illumina reads of length 20 and 36 since no longer reads could be obtained for this organism.) The relative results and conclusion are similar for all read sets; sensitivies are higher for all read mappers, due to the lower repeat content of the genome. Notably, Shrimp2 does not gain as much as the other read mappers on the Illumina reads, but still achieves a high sensitivity.</p></sec><sec><title>Simulated Data</title><p>Tables <xref ref-type="table" rid="T1">1</xref> and S7 show the sensitivity of the read mappers on simulated data for fly (and yeast). Bwa and Shrimp2 consistently yield the best results, finding the best locations of at least 90% of all intervals on all read sets. The results for yeast reads are better than for fly reads. The most likely explanation is the lower complexity of the yeast genome with less ambiguities. Both read mappers' quality <italic>increases</italic>, with increasing read length, probably because of the same reason: The longer the reads are, the less ambiguities there are.</p><table-wrap id="T1" position="float"><label>Table 1</label><caption><p>Performance in found interval percentage for the read mappers on simulated D. melanogaster reads.</p></caption><table frame="hsides" rules="groups"><thead><tr><th/><th align="center">Illumina<break/>36 bp</th><th align="center">Illumina<break/>50 bp</th><th align="center">Illumina<break/>100 bp</th><th align="center">454<break/>&#x000d8; 200 bp</th><th align="center">454<break/>&#x000d8;400 bp</th></tr></thead><tbody><tr><td align="left">Bowtie</td><td align="center">78.5</td><td align="center">72.2</td><td align="center">55.0</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="left">Bowtie*</td><td align="center">78.5</td><td align="center">72.2</td><td align="center">59.2</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="left">Bwa</td><td align="center">92.7</td><td align="center">93.5</td><td align="center">93.8</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="left">Shrimp2</td><td align="center">90.1</td><td align="center">91.1</td><td align="center">92.8</td><td align="center">89.7</td><td align="center">92.9</td></tr><tr><td align="left">Soap</td><td align="center">79.6</td><td align="center">73.1</td><td align="center">54.7</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="left">Soap*</td><td align="center">79.8</td><td align="center">73.1</td><td align="center">57.5</td><td align="center">-</td><td align="center">-</td></tr></tbody></table><table-wrap-foot><p>Data is given for mapping in edit distance mode. 454 reads were only mapped with Shrimp2.</p></table-wrap-foot></table-wrap><p>Bowtie and Soap2 do not support indels and are consequently not robust against the rising number of indels in the longer reads. This can be seen in the decreasing quality of their results. The optimized parametrizations yield slightly better results than the default parametrizations. In total, Bowtie finds slightly more original locations than Soap2, probably because of support for base qualities.</p></sec></sec><sec><title>3.2 Usages For Our Method</title><p>Our method is very useful for the <italic>exact </italic>validation of read mapper results. It can be used to compute the exact percentage of matches found by a read mapper. This can be done for large samples of read data sets, 10,000 in our example, but more are possible.</p><p>For performing a comparison of read mappers, we propose the following guidelines:</p><p>1) Use reads from state-of-the-art technology with popular parameters for size and paired-end modes. 2) Use current versions of popular tools from multiple paradigms, such as index-based filtration-based read mappers. 3) Run the read mappers with various parametrizations, including default parameters, possibly allowing the read mapper authors to provide the best possible parameters. 4) Use a method based on a formal definition, e.g. Rabema, to perform an exact assessment of read mapper quality. 5) Complement this with heuristic measures such as counting mapped and uniquely mapped reads for datasets of real-world-size, taking into considerations the notes in Section 2.2 about possibly missed duplicate matches. 6) Possibly, show how the results of downstream analysis differ between two read mappers. </p><p>Our method gives a <italic>gold standard </italic>for the read mapping problem. This works for both simulated and real-world read sets and allows to put each read mapper not only in relation to other read mappers, but to an optimal solution.</p><p>Furthermore, the implementation of our method allows to print missed equivalence classes/intervals. This allows the analysis of why a read mapper does not find certain matches. It can also be used to debug and improve read mappers as well as evaluate the automatic computation of read mapper parametrization. If a read mapper finds a location that is not in the generated gold standard then this is reported by our tool as well and can be seen and used as a sanity check.</p></sec></sec><sec><title>4 Conclusions</title><p>We presented a benchmark for read mapping, beginning with the distinction of the biological problem and a mathematical abstraction. For the mathematical abstraction, we gave a precise problem definition which allows to define the required results. Our method works both for real-world reads and simulated data.</p><p>We implemented tools to build the introduced gold standard and performed a comparison of several popular read mapping tools. The example comparison uses Illumina and 454 reads, both real-world and simulated data. We found that Shrimp2 is a highly sensitive tool for detecting multiple matches. Bwa is a very diverse tool and especially good for finding one of the best alignments of a read. Soap2 and Bowtie are both good choices for mapping short reads quickly and sensitively, Bowtie being a slightly better choice according to our analysis.</p><p>Currently, our method is limited to base-space reads. However, three of the four currently commercially available 2G sequencing platform (including the widely used Illumina technology), create reads in base space. Thus, our method is useful for a wide audience.</p><p>The online material at <ext-link ext-link-type="uri" xlink:href="http://www.seqan.de/projects/rabema.html">http://www.seqan.de/projects/rabema.html</ext-link> contains download links for the reference sequences and read sets we used, the resulting SAM files, the tools for the benchmark evaluation, and a manual.</p><sec><title>4.1 Future Work</title><p>At the moment, the generator for the gold standard does not incorporate mate pair information and quality values. We plan to add support for this in a future release. Note that read mapper programs incorporating mate-pair and quality value information can already leverage this information in benchmarks for the biological problem.</p><p>Another point for improvement is allowing to use ABI SOLiD [<xref ref-type="bibr" rid="B21">21</xref>] reads. For this, support for color-space sequences has to be added to SeqAn, the gold standard generator has to be adapted to support them and Razers (or another exact read mapper) has to be extended to work with color-space reads. More details on this can be found in Section S3.</p></sec></sec><sec><title>5 Authors' contributions</title><p>The original idea of the benchmark came from DW and KR. DW came up with the intuition of the error landscape. From this idea, MH derived the exact definition through equivalence classes, trace and neighbour equivalency, implemented the software and wrote most of the paper. AKE helped with the experimental evaluation. Additionally, AKE, DW and KR contributed equally to the work through discussion and editing.</p><p>All authors read and approved the final manuscript.</p></sec><sec sec-type="supplementary-material"><title>Supplementary Material</title><supplementary-material content-type="local-data" id="S1"><caption><title>Additional file 1</title><p><bold>Supplemental Material</bold>. This file contains supplemental text, figures, and tables.</p></caption><media xlink:href="1471-2105-12-210-S1.PDF" mimetype="application" mime-subtype="pdf"><caption><p>Click here for file</p></caption></media></supplementary-material></sec></body><back><sec><title>6 Acknowledgements</title><p>We would like to thank the anonymous reviewers for their constructive comments.</p><p>MH was supported by the DFG priority program Algorithm Engineering (SPP1307) through DFG grant RE-1712/3-1. AKE is funded by an IMPRS-CBSC stipend.</p><p>The programs that were used to perform the evaluation are based on SeqAn [<xref ref-type="bibr" rid="B22">22</xref>], the C++ library for sequence analysis.</p></sec><ref-list><ref id="B1"><mixed-citation publication-type="journal"><name><surname>Bentley</surname><given-names>DR</given-names></name><name><surname>Balasubramanian</surname><given-names>S</given-names></name><name><surname>Swerdlow</surname><given-names>HP</given-names></name><name><surname>Smith</surname><given-names>GP</given-names></name><name><surname>Milton</surname><given-names>J</given-names></name><name><surname>Brown</surname><given-names>CG</given-names></name><name><surname>Hall</surname><given-names>KP</given-names></name><name><surname>Evers</surname><given-names>DJ</given-names></name><name><surname>Barnes</surname><given-names>CL</given-names></name><name><surname>Bignell</surname><given-names>HR</given-names></name><name><surname>Boutell</surname><given-names>JM</given-names></name><name><surname>Bryant</surname><given-names>J</given-names></name><name><surname>Carter</surname><given-names>RJ</given-names></name><name><surname>Keira Cheetham</surname><given-names>R</given-names></name><name><surname>Cox</surname><given-names>AJ</given-names></name><name><surname>Ellis</surname><given-names>DJ</given-names></name><name><surname>Flatbush</surname><given-names>MR</given-names></name><name><surname>Gormley</surname><given-names>NA</given-names></name><name><surname>Humphray</surname><given-names>SJ</given-names></name><name><surname>Irving</surname><given-names>LJ</given-names></name><name><surname>Karbelashvili</surname><given-names>MS</given-names></name><name><surname>Kirk</surname><given-names>SM</given-names></name><name><surname>Li</surname><given-names>H</given-names></name><name><surname>Liu</surname><given-names>X</given-names></name><name><surname>Maisinger</surname><given-names>KS</given-names></name><name><surname>Murray</surname><given-names>LJ</given-names></name><name><surname>Obradovic</surname><given-names>B</given-names></name><name><surname>Ost</surname><given-names>T</given-names></name><name><surname>Parkinson</surname><given-names>ML</given-names></name><name><surname>Pratt</surname><given-names>MR</given-names></name><etal/><article-title>Accurate whole human genome sequencing using reversible terminator chemistry</article-title><source>Nature</source><year>2008</year><volume>456</volume><issue>7218</issue><fpage>53</fpage><lpage>9</lpage><pub-id pub-id-type="doi">10.1038/nature07517</pub-id><pub-id pub-id-type="pmid">18987734</pub-id></mixed-citation></ref><ref id="B2"><mixed-citation publication-type="journal"><name><surname>Wheeler</surname><given-names>DA</given-names></name><name><surname>Srinivasan</surname><given-names>M</given-names></name><name><surname>Egholm</surname><given-names>M</given-names></name><name><surname>Shen</surname><given-names>Y</given-names></name><name><surname>Chen</surname><given-names>L</given-names></name><name><surname>McGuire</surname><given-names>A</given-names></name><name><surname>He</surname><given-names>W</given-names></name><name><surname>Chen</surname><given-names>YJ</given-names></name><name><surname>Makhijani</surname><given-names>V</given-names></name><name><surname>Roth</surname><given-names>GT</given-names></name><name><surname>Gomes</surname><given-names>X</given-names></name><name><surname>Tartaro</surname><given-names>K</given-names></name><name><surname>Niazi</surname><given-names>F</given-names></name><name><surname>Turcotte</surname><given-names>CL</given-names></name><name><surname>Irzyk</surname><given-names>GP</given-names></name><name><surname>Lupski</surname><given-names>JR</given-names></name><name><surname>Chinault</surname><given-names>C</given-names></name><name><surname>zhi Song</surname><given-names>X</given-names></name><name><surname>Liu</surname><given-names>Y</given-names></name><name><surname>Yuan</surname><given-names>Y</given-names></name><name><surname>Nazareth</surname><given-names>L</given-names></name><name><surname>Qin</surname><given-names>X</given-names></name><name><surname>Muzny</surname><given-names>DM</given-names></name><name><surname>Margulies</surname><given-names>M</given-names></name><name><surname>Weinstock</surname><given-names>GM</given-names></name><name><surname>Gibbs</surname><given-names>RA</given-names></name><name><surname>Rothberg</surname><given-names>JM</given-names></name><article-title>The complete genome of an individual by massively parallel DNA sequencing</article-title><source>Nature</source><year>2008</year><volume>452</volume><issue>7189</issue><fpage>872</fpage><lpage>876</lpage><pub-id pub-id-type="doi">10.1038/nature06884</pub-id><pub-id pub-id-type="pmid">18421352</pub-id></mixed-citation></ref><ref id="B3"><mixed-citation publication-type="journal"><name><surname>McKernan</surname><given-names>KJ</given-names></name><name><surname>Peckham</surname><given-names>HE</given-names></name><name><surname>Costa</surname><given-names>GL</given-names></name><name><surname>McLaughlin</surname><given-names>SF</given-names></name><name><surname>Fu</surname><given-names>Y</given-names></name><name><surname>Tsung</surname><given-names>EF</given-names></name><name><surname>Clouser</surname><given-names>CR</given-names></name><name><surname>Duncan</surname><given-names>C</given-names></name><name><surname>Ichikawa</surname><given-names>JK</given-names></name><name><surname>Lee</surname><given-names>CC</given-names></name><name><surname>Zhang</surname><given-names>Z</given-names></name><name><surname>Ranade</surname><given-names>SS</given-names></name><name><surname>Dimalanta</surname><given-names>ET</given-names></name><name><surname>Hyland</surname><given-names>FC</given-names></name><name><surname>Sokolsky</surname><given-names>TD</given-names></name><name><surname>Zhang</surname><given-names>L</given-names></name><name><surname>Sheridan</surname><given-names>A</given-names></name><name><surname>Fu</surname><given-names>H</given-names></name><name><surname>Hendrickson</surname><given-names>CL</given-names></name><name><surname>Li</surname><given-names>B</given-names></name><name><surname>Kotler</surname><given-names>L</given-names></name><name><surname>Stuart</surname><given-names>JR</given-names></name><name><surname>Malek</surname><given-names>JA</given-names></name><name><surname>Manning</surname><given-names>JM</given-names></name><name><surname>Antipova</surname><given-names>AA</given-names></name><name><surname>Perez</surname><given-names>DS</given-names></name><name><surname>Moore</surname><given-names>MP</given-names></name><name><surname>Hayashibara</surname><given-names>KC</given-names></name><etal/><article-title>Sequence and structural variation in a human genome uncovered by short-read, massively parallel ligation sequencing using two-base encoding</article-title><source>Genome Res</source><year>2009</year><volume>19</volume><issue>9</issue><fpage>1527</fpage><lpage>1541</lpage><pub-id pub-id-type="doi">10.1101/gr.091868.109</pub-id><pub-id pub-id-type="pmid">19546169</pub-id></mixed-citation></ref><ref id="B4"><mixed-citation publication-type="journal"><name><surname>Ng</surname><given-names>SB</given-names></name><name><surname>Turner</surname><given-names>EH</given-names></name><name><surname>Robertson</surname><given-names>PD</given-names></name><name><surname>Flygare</surname><given-names>SD</given-names></name><name><surname>Bigham</surname><given-names>AW</given-names></name><name><surname>Lee</surname><given-names>C</given-names></name><name><surname>Shaffer</surname><given-names>T</given-names></name><name><surname>Wong</surname><given-names>M</given-names></name><name><surname>Bhattacharjee</surname><given-names>A</given-names></name><name><surname>Eichler</surname><given-names>EE</given-names></name><name><surname>Bamshad</surname><given-names>M</given-names></name><name><surname>Nickerson</surname><given-names>DA</given-names></name><name><surname>Shendure</surname><given-names>J</given-names></name><article-title>Targeted capture and massively parallel sequencing of 12 human exomes</article-title><source>Nature</source><year>2009</year><volume>461</volume><issue>7261</issue><fpage>272</fpage><lpage>276</lpage><pub-id pub-id-type="doi">10.1038/nature08250</pub-id><pub-id pub-id-type="pmid">19684571</pub-id></mixed-citation></ref><ref id="B5"><mixed-citation publication-type="journal"><name><surname>Valouev</surname><given-names>A</given-names></name><name><surname>Johnson</surname><given-names>DS</given-names></name><name><surname>Sundquist</surname><given-names>A</given-names></name><name><surname>Medina</surname><given-names>C</given-names></name><name><surname>Anton</surname><given-names>E</given-names></name><name><surname>Batzoglou</surname><given-names>S</given-names></name><name><surname>Myers</surname><given-names>RM</given-names></name><name><surname>Sidow</surname><given-names>A</given-names></name><article-title>Genome-wide analysis of transcription factor binding sites based on ChIP-Seq data</article-title><source>Nat Methods</source><year>2008</year><volume>5</volume><issue>9</issue><fpage>829</fpage><lpage>834</lpage><pub-id pub-id-type="doi">10.1038/nmeth.1246</pub-id><pub-id pub-id-type="pmid">19160518</pub-id></mixed-citation></ref><ref id="B6"><mixed-citation publication-type="journal"><name><surname>Deng</surname><given-names>J</given-names></name><name><surname>Shoemaker</surname><given-names>R</given-names></name><name><surname>Xie</surname><given-names>B</given-names></name><name><surname>Gore</surname><given-names>A</given-names></name><name><surname>LeProust</surname><given-names>EM</given-names></name><name><surname>Antosiewicz-Bourget</surname><given-names>J</given-names></name><name><surname>Egli</surname><given-names>D</given-names></name><name><surname>Maherali</surname><given-names>N</given-names></name><name><surname>Park</surname><given-names>IH</given-names></name><name><surname>Yu</surname><given-names>J</given-names></name><name><surname>Daley</surname><given-names>GQ</given-names></name><name><surname>Eggan</surname><given-names>K</given-names></name><name><surname>Hochedlinger</surname><given-names>K</given-names></name><name><surname>Thomson</surname><given-names>J</given-names></name><name><surname>Wang</surname><given-names>W</given-names></name><name><surname>Gao</surname><given-names>Y</given-names></name><name><surname>Zhang</surname><given-names>K</given-names></name><article-title>Targeted bisulfite sequencing reveals changes in DNA methylation associated with nuclear reprogramming</article-title><source>Nat Biotechnol</source><year>2009</year><volume>27</volume><issue>4</issue><fpage>353</fpage><lpage>360</lpage><pub-id pub-id-type="doi">10.1038/nbt.1530</pub-id><pub-id pub-id-type="pmid">19330000</pub-id></mixed-citation></ref><ref id="B7"><mixed-citation publication-type="journal"><name><surname>Qin</surname><given-names>J</given-names></name><name><surname>Li</surname><given-names>R</given-names></name><name><surname>Raes</surname><given-names>J</given-names></name><name><surname>Arumugam</surname><given-names>M</given-names></name><name><surname>Burgdorf</surname><given-names>KS</given-names></name><name><surname>Manichanh</surname><given-names>C</given-names></name><name><surname>Nielsen</surname><given-names>T</given-names></name><name><surname>Pons</surname><given-names>N</given-names></name><name><surname>Levenez</surname><given-names>F</given-names></name><name><surname>Yamada</surname><given-names>T</given-names></name><name><surname>Mende</surname><given-names>DR</given-names></name><name><surname>Li</surname><given-names>J</given-names></name><name><surname>Xu</surname><given-names>J</given-names></name><name><surname>Li</surname><given-names>S</given-names></name><name><surname>Li</surname><given-names>D</given-names></name><name><surname>Cao</surname><given-names>J</given-names></name><name><surname>Wang</surname><given-names>B</given-names></name><name><surname>Liang</surname><given-names>H</given-names></name><name><surname>Zheng</surname><given-names>H</given-names></name><name><surname>Xie</surname><given-names>Y</given-names></name><name><surname>Tap</surname><given-names>J</given-names></name><name><surname>Lepage</surname><given-names>P</given-names></name><name><surname>Bertalan</surname><given-names>M</given-names></name><name><surname>Batto</surname><given-names>JM</given-names></name><name><surname>Hansen</surname><given-names>T</given-names></name><name><surname>Le Paslier</surname><given-names>D</given-names></name><name><surname>Linneberg</surname><given-names>A</given-names></name><name><surname>Nielsen</surname><given-names>HB</given-names></name><name><surname>Pelletier</surname><given-names>E</given-names></name><etal/><article-title>A human gut microbial gene catalogue established by metagenomic sequencing</article-title><source>Nature</source><year>2010</year><volume>464</volume><issue>7285</issue><fpage>59</fpage><lpage>65</lpage><pub-id pub-id-type="doi">10.1038/nature08821</pub-id><pub-id pub-id-type="pmid">20203603</pub-id></mixed-citation></ref><ref id="B8"><mixed-citation publication-type="journal"><name><surname>Li</surname><given-names>R</given-names></name><name><surname>Yu</surname><given-names>C</given-names></name><name><surname>Li</surname><given-names>Y</given-names></name><name><surname>Lam</surname><given-names>TW</given-names></name><name><surname>Yiu</surname><given-names>SM</given-names></name><name><surname>Kristiansen</surname><given-names>K</given-names></name><name><surname>Wang</surname><given-names>J</given-names></name><article-title>SOAP2: an improved ultrafast tool for short read alignment</article-title><source>Bioinformatics</source><year>2009</year><volume>25</volume><issue>15</issue><fpage>1966</fpage><lpage>1967</lpage><pub-id pub-id-type="doi">10.1093/bioinformatics/btp336</pub-id><pub-id pub-id-type="pmid">19497933</pub-id></mixed-citation></ref><ref id="B9"><mixed-citation publication-type="journal"><name><surname>Li</surname><given-names>H</given-names></name><name><surname>Durbin</surname><given-names>R</given-names></name><article-title>Fast and accurate short read alignment with Burrows-Wheeler transform</article-title><source>Bioinformatics</source><year>2009</year><volume>25</volume><issue>14</issue><fpage>1754</fpage><lpage>1760</lpage><pub-id pub-id-type="doi">10.1093/bioinformatics/btp324</pub-id><pub-id pub-id-type="pmid">19451168</pub-id></mixed-citation></ref><ref id="B10"><mixed-citation publication-type="other"><name><surname>David</surname><given-names>M</given-names></name><name><surname>Dzamba</surname><given-names>M</given-names></name><name><surname>Lister</surname><given-names>D</given-names></name><name><surname>Ilie</surname><given-names>L</given-names></name><name><surname>Brudno</surname><given-names>M</given-names></name><article-title>SHRiMP2: Sensitive yet Practical Short Read Mapping</article-title><source>Bioinformatics</source><comment> in press </comment></mixed-citation></ref><ref id="B11"><mixed-citation publication-type="journal"><name><surname>Langmead</surname><given-names>B</given-names></name><name><surname>Trapnell</surname><given-names>C</given-names></name><name><surname>Pop</surname><given-names>M</given-names></name><name><surname>Salzberg</surname><given-names>S</given-names></name><article-title>Ultrafast and memory-efficient alignment of short DNA sequences to the human genome</article-title><source>Genome Biol</source><year>2009</year><volume>10</volume><issue>3</issue><fpage>R25</fpage><pub-id pub-id-type="doi">10.1186/gb-2009-10-3-r25</pub-id><pub-id pub-id-type="pmid">19261174</pub-id></mixed-citation></ref><ref id="B12"><mixed-citation publication-type="journal"><name><surname>Weese</surname><given-names>D</given-names></name><name><surname>Emde</surname><given-names>AK</given-names></name><name><surname>Rausch</surname><given-names>T</given-names></name><name><surname>D&#x000f6;ring</surname><given-names>A</given-names></name><name><surname>Reinert</surname><given-names>K</given-names></name><article-title>RazerS-fast read mapping with sensitivity control</article-title><source>Genome Res</source><year>2009</year><volume>19</volume><issue>9</issue><fpage>1646</fpage><lpage>1654</lpage><pub-id pub-id-type="doi">10.1101/gr.088823.108</pub-id><pub-id pub-id-type="pmid">19592482</pub-id></mixed-citation></ref><ref id="B13"><mixed-citation publication-type="journal"><name><surname>Dohm</surname><given-names>J</given-names></name><name><surname>Lottaz</surname><given-names>C</given-names></name><name><surname>Borodina</surname><given-names>T</given-names></name><name><surname>Himmelbauer</surname><given-names>H</given-names></name><article-title>Substantial biases in ultra-short read data sets from high-throughput DNA sequencing</article-title><source>Nucleic Acids Res</source><year>2008</year><volume>36</volume></mixed-citation></ref><ref id="B14"><mixed-citation publication-type="journal"><name><surname>Amid</surname><given-names>C</given-names></name><name><surname>Frankish</surname><given-names>A</given-names></name><name><surname>Aken</surname><given-names>B</given-names></name><name><surname>Ezkurdia</surname><given-names>I</given-names></name><name><surname>Kokocinsk</surname><given-names>F</given-names></name><name><surname>Gilbert</surname><given-names>J</given-names></name><name><surname>White</surname><given-names>S</given-names></name><name><surname>Carninci</surname><given-names>P</given-names></name><name><surname>Gingeras</surname><given-names>T</given-names></name><name><surname>Guigo</surname><given-names>R</given-names></name><name><surname>Searle</surname><given-names>S</given-names></name><name><surname>Tress</surname><given-names>ML</given-names></name><name><surname>Harrow</surname><given-names>J</given-names></name><name><surname>Hubbard</surname><given-names>T</given-names></name><article-title>From identification to validation to gene count</article-title><source>Genome Biol</source><year>2010</year><volume>11</volume><issue>Suppl 1</issue><fpage>O1</fpage></mixed-citation></ref><ref id="B15"><mixed-citation publication-type="journal"><name><surname>Guig&#x000f3;</surname><given-names>R</given-names></name><name><surname>Flicek</surname><given-names>P</given-names></name><name><surname>Abril</surname><given-names>JF</given-names></name><name><surname>Reymond</surname><given-names>A</given-names></name><name><surname>Lagarde</surname><given-names>J</given-names></name><name><surname>Denoeud</surname><given-names>F</given-names></name><name><surname>Antonarakis</surname><given-names>S</given-names></name><name><surname>Ashburner</surname><given-names>M</given-names></name><name><surname>Bajic</surname><given-names>VB</given-names></name><name><surname>Birney</surname><given-names>E</given-names></name><name><surname>Castelo</surname><given-names>R</given-names></name><name><surname>Eyras</surname><given-names>E</given-names></name><name><surname>Ucla</surname><given-names>C</given-names></name><name><surname>Gingeras</surname><given-names>TR</given-names></name><name><surname>Harrow</surname><given-names>J</given-names></name><name><surname>Hubbard</surname><given-names>T</given-names></name><name><surname>Lewis</surname><given-names>SE</given-names></name><name><surname>Reese</surname><given-names>MG</given-names></name><article-title>EGASP: the human ENCODE genome annotation assessment project</article-title><source>Genome Biol</source><year>2006</year><volume>7</volume><issue>Suppl 1</issue><fpage>S2</fpage><pub-id pub-id-type="doi">10.1186/gb-2006-7-s1-s2</pub-id><pub-id pub-id-type="pmid">16925836</pub-id></mixed-citation></ref><ref id="B16"><mixed-citation publication-type="other"><name><surname>Sanders</surname><given-names>P</given-names></name><article-title><italic>Algorithm Engineering-An Attempt at a Definition</italic>, Springer Berlin/Heidelberg</article-title><year>2009</year><volume>5760</volume><fpage>321</fpage><lpage>340</lpage></mixed-citation></ref><ref id="B17"><mixed-citation publication-type="other"><name><surname>Navarro</surname><given-names>G</given-names></name><name><surname>Raffinot</surname><given-names>M</given-names></name><source>Flexible Pattern Matching in Strings CUP</source><year>2002</year></mixed-citation></ref><ref id="B18"><mixed-citation publication-type="journal"><name><surname>Myers</surname><given-names>G</given-names></name><article-title>A fast bit-vector algorithm for approximate string matching based on dynamic programming</article-title><source>J ACM</source><year>1999</year><volume>46</volume><issue>3</issue><fpage>395</fpage><lpage>415</lpage><pub-id pub-id-type="doi">10.1145/316542.316550</pub-id></mixed-citation></ref><ref id="B19"><mixed-citation publication-type="journal"><name><surname>Alkan</surname><given-names>C</given-names></name><name><surname>Kidd</surname><given-names>JM</given-names></name><name><surname>Marques-Bonet</surname><given-names>T</given-names></name><name><surname>Aksay</surname><given-names>G</given-names></name><name><surname>Antonacci</surname><given-names>F</given-names></name><name><surname>Hormozdiari</surname><given-names>F</given-names></name><name><surname>Kitzman</surname><given-names>JO</given-names></name><name><surname>Baker</surname><given-names>C</given-names></name><name><surname>Malig</surname><given-names>M</given-names></name><name><surname>Mutlu</surname><given-names>O</given-names></name><name><surname>Sahinalp</surname><given-names>SC</given-names></name><name><surname>Gibbs</surname><given-names>RA</given-names></name><name><surname>Eichler</surname><given-names>EE</given-names></name><article-title>Personalized copy number and segmental duplication maps using next-generation sequencing</article-title><source>Nat Genet</source><year>2009</year><volume>41</volume><issue>10</issue><fpage>1061</fpage><lpage>1067</lpage><pub-id pub-id-type="doi">10.1038/ng.437</pub-id><pub-id pub-id-type="pmid">19718026</pub-id></mixed-citation></ref><ref id="B20"><mixed-citation publication-type="book"><name><surname>Holtgrewe</surname><given-names>M</given-names></name><source>Mason - A Read Simulator for Second Generation Sequencing Data</source><year>2010</year><publisher-name>Tech Rep TR-B-10-06, Institut f&#x000fc;r Mathematik und Informatik, Freie Universit&#x000e4;t Berlin</publisher-name></mixed-citation></ref><ref id="B21"><mixed-citation publication-type="journal"><name><surname>Mardis</surname><given-names>ER</given-names></name><article-title>New strategies and emerging technologies for massively parallel sequencing: applications in medical research</article-title><source>Genome Med</source><year>2009</year><volume>1</volume><issue>4</issue><fpage>40</fpage><pub-id pub-id-type="doi">10.1186/gm40</pub-id><pub-id pub-id-type="pmid">19435481</pub-id></mixed-citation></ref><ref id="B22"><mixed-citation publication-type="journal"><name><surname>D&#x000f6;ring</surname><given-names>A</given-names></name><name><surname>Weese</surname><given-names>D</given-names></name><name><surname>Rausch</surname><given-names>T</given-names></name><name><surname>Reinert</surname><given-names>K</given-names></name><article-title>SeqAn an efficient, generic C++ library for sequence analysis</article-title><source>BMC Bioinf</source><year>2008</year><volume>9</volume><fpage>11</fpage><pub-id pub-id-type="doi">10.1186/1471-2105-9-11</pub-id></mixed-citation></ref></ref-list></back></article>
<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD v1.0 20120330//EN" "JATS-archivearticle1.dtd"> 
<article xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:mml="http://www.w3.org/1998/Math/MathML" article-type="research-article" xml:lang="en"><?DTDIdentifier.IdentifierValue article.dtd?><?DTDIdentifier.IdentifierType system?><?SourceDTD.DTDName article.dtd?><?SourceDTD.Version 1.0?><?ConverterInfo.XSLTName bmc2nlmx2.xsl?><?ConverterInfo.Version 2?><front><journal-meta><journal-id journal-id-type="nlm-ta">Algorithms Mol Biol</journal-id><journal-id journal-id-type="iso-abbrev">Algorithms Mol Biol</journal-id><journal-title-group><journal-title>Algorithms for Molecular Biology : AMB</journal-title></journal-title-group><issn pub-type="epub">1748-7188</issn><publisher><publisher-name>BioMed Central</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="pmcid">3977952</article-id><article-id pub-id-type="publisher-id">1748-7188-9-6</article-id><article-id pub-id-type="pmid">24612691</article-id><article-id pub-id-type="doi">10.1186/1748-7188-9-6</article-id><article-categories><subj-group subj-group-type="heading"><subject>Software Article</subject></subj-group></article-categories><title-group><article-title>Segmentor3IsBack: an R package for the fast and exact segmentation of Seq-data</article-title></title-group><contrib-group><contrib contrib-type="author" corresp="yes" id="A1"><name><surname>Cleynen</surname><given-names>Alice</given-names></name><xref ref-type="aff" rid="I1">1</xref><xref ref-type="aff" rid="I2">2</xref><email>acleynen@jimmy.harvard.edu</email></contrib><contrib contrib-type="author" id="A2"><name><surname>Koskas</surname><given-names>Michel</given-names></name><xref ref-type="aff" rid="I1">1</xref><xref ref-type="aff" rid="I2">2</xref><email>michel.koskas@agroparistech.fr</email></contrib><contrib contrib-type="author" id="A3"><name><surname>Lebarbier</surname><given-names>Emilie</given-names></name><xref ref-type="aff" rid="I1">1</xref><xref ref-type="aff" rid="I2">2</xref><email>emilie.lebarbier@agroparistech.fr</email></contrib><contrib contrib-type="author" id="A4"><name><surname>Rigaill</surname><given-names>Guillem</given-names></name><xref ref-type="aff" rid="I3">3</xref><email>rigaill@evry.inra.fr</email></contrib><contrib contrib-type="author" id="A5"><name><surname>Robin</surname><given-names>St&#x000e9;phane</given-names></name><xref ref-type="aff" rid="I1">1</xref><xref ref-type="aff" rid="I2">2</xref><email>robin@agroparistech.fr</email></contrib></contrib-group><aff id="I1"><label>1</label>AgroParisTech, UMR 518, 16 rue Claude Bernard, 75231 Paris Cedex 05, France</aff><aff id="I2"><label>2</label>INRA, UMR 518, 16 rue Claude Bernard, 75231 Paris Cedex 05, France</aff><aff id="I3"><label>3</label>, Unit&#x000e9; de Recherche en G&#x000e9;nomique V&#x000e9;g&#x000e9;tale (URGV) INRA-CNRS-Universit&#x000e9; d&#x02019;Evry Val d&#x02019;Essonne, 2 Rue Gaston Cr&#x000e9;mieux, 91057 Evry Cedex, France</aff><pub-date pub-type="collection"><year>2014</year></pub-date><pub-date pub-type="epub"><day>10</day><month>3</month><year>2014</year></pub-date><volume>9</volume><fpage>6</fpage><lpage>6</lpage><history><date date-type="received"><day>13</day><month>5</month><year>2013</year></date><date date-type="accepted"><day>3</day><month>3</month><year>2014</year></date></history><permissions><copyright-statement>Copyright &#x000a9; 2014 Cleynen et al.; licensee BioMed Central Ltd.</copyright-statement><copyright-year>2014</copyright-year><copyright-holder>Cleynen et al.; licensee BioMed Central Ltd.</copyright-holder><license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/2.0"><license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/2.0">http://creativecommons.org/licenses/by/2.0</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p></license></permissions><self-uri xlink:href="http://www.almob.org/content/9/1/6"/><abstract><sec><title>Background</title><p>Change point problems arise in many genomic analyses such as the detection of copy number variations or the detection of transcribed regions. The expanding Next Generation Sequencing technologies now allow to locate change points at the nucleotide resolution.</p></sec><sec><title>Results</title><p>Because of its complexity which is almost linear in the sequence length when the maximal number of segments is constant, and as its performance had been acknowledged for microarrays, we propose to use the Pruned Dynamic Programming algorithm for Seq-experiment outputs. This requires the adaptation of the algorithm to the negative binomial distribution with which we model the data. We show that if the dispersion in the signal is known, the PDP algorithm can be used, and we provide an estimator for this dispersion. We describe a compression framework which reduces the time complexity without modifying the accuracy of the segmentation. We propose to estimate the number of segments via a penalized likelihood criterion. We illustrate the performance of the proposed methodology on RNA-Seq data.</p></sec><sec><title>Conclusions</title><p>We illustrate the results of our approach on a real dataset and show its good performance. Our algorithm is available as an <italic>R</italic> package on the CRAN repository.</p></sec></abstract><kwd-group><kwd>Segmentation algorithm</kwd><kwd>Exact algorithm</kwd><kwd>Fast algorithm</kwd><kwd>RNA-Seq data</kwd><kwd>Genome annotation</kwd><kwd>Count data</kwd><kwd>Data compression</kwd></kwd-group></article-meta></front><body><sec><title>Background</title><p>Change-point detection methods have long been used in the analysis of genetic data as an efficient tool in the study of DNA sequences for various purposes. For instance, segmentation methods have been developed for categorical variables with the aim of identifying patterns for gene predictions [<xref ref-type="bibr" rid="B1">1</xref>,<xref ref-type="bibr" rid="B2">2</xref>], while SNPs have been detected using sequence segmentation [<xref ref-type="bibr" rid="B3">3</xref>]. In the last two decades, with the large spread of micro-arrays, change-point methods have been widely used for the analysis of DNA copy number variations and the identification of amplification or deletion of genomic regions in pathologies such as cancer [<xref ref-type="bibr" rid="B4">4</xref>-<xref ref-type="bibr" rid="B8">8</xref>].</p><p>The recent development of Next-Generation Sequencing technologies gives rise to new applications along with new difficulties: (<italic>a</italic>) the increased size of profiles (up to 10<sup>8</sup> data-points when micro-array signals were closer to 10<sup>5</sup>), and (<italic>b</italic>) the discrete nature of the output (number of reads starting at each position of the genome). Yet applying segmentation methods to DNA-Seq data with their greater resolution should lead to the analysis of copy-number variation with a much improved precision compared to CGH arrays. Moreover, in the case of poly-(A) RNA-Seq data on lower organisms, since coding regions of the genome are well separated from non-coding regions with lower activity, segmentation methods should allow the identification of transcribed genes as well as address the issue of new transcript discovery. Our objective is therefore to develop a segmentation method to tackle both (<italic>a</italic>) and (<italic>b</italic>) with some specific requirements: the amount of reads falling within a segment should be representative of the biological information associated (relative copy-number of the region, relative level of expression of the gene), and comparison to neighboring regions should be sufficient to label the segment (for instance normal or deleted region of the chromosome in DNA-Seq data, exon or non-transcribed region in RNA-Seq), therefore no comparison profile should be needed. This also suppresses the need for normalization, and consequently we wish to analyze the raw count-profile.</p><p>Up to now, most methods addressing the analysis of these datasets require some normalization process to allow the use of algorithms which rely on Gaussian-distributed data or which were previously developed for micro-arrays [<xref ref-type="bibr" rid="B9">9</xref>-<xref ref-type="bibr" rid="B12">12</xref>]. Indeed, methods adapted to count datasets are not numerous and are highly focused on the Poisson distribution. Alteration of genomic sequences can be detected based on the comparison of Poisson processes associated with the read counts of a case and a control sample [<xref ref-type="bibr" rid="B13">13</xref>], but this cannot be applied to the detection of transcribed regions in a single condition.</p><p>Still, a likelihood ratio statistic was proposed for the localization of a shift in the intensity of a Poisson process [<xref ref-type="bibr" rid="B14">14</xref>], and a test statistic was proposed for the existence of a change-point in the Poisson autoregression of order 1 [<xref ref-type="bibr" rid="B15">15</xref>].</p><p>These last two methods do not require a comparison profile but they only allow for the detection of a single change-point and have too high a time-complexity to be applied to RNA-Seq profiles. Binary Segmentation, a fast heuristic [<xref ref-type="bibr" rid="B6">6</xref>], and Pruned Exact Linear Time (PELT) [<xref ref-type="bibr" rid="B16">16</xref>], an exact algorithm for optimal segmentation with respect to the likelihood, are both implemented for the Poisson distribution in the <bold>changepoint</bold> package. Even though both are extremely fast, do not require a comparison profile, and analyze count-data, the Poisson distribution is not adapted to our kind of datasets.</p><p>A recent study [<xref ref-type="bibr" rid="B17">17</xref>] has compared 13 segmentation methods for the analysis of chromosomal copy number profiles and has shown the excellent performance of the Pruned Dynamic Programming (PDP) algorithm [<xref ref-type="bibr" rid="B18">18</xref>] proposed in its initial implementation for the analysis of Gaussian data in the <italic>R</italic> package <bold>cghseg</bold>. We propose to use this algorithm, which we have implemented for the Poisson and negative binomial distributions.</p><p>In the next section we recall the general segmentation framework and the definition and requirements of the PDP algorithm. Our contributions are given in the third section where we define the negative binomial model and show that it satisfies the PDP algorithm requirements. We also provide a theoretical result for the possibility to compress the data, and finally we give a model selection criterion with theoretical guarantees, which makes the whole approach complete. We conclude with a simulation study, which illustrates the performance of the proposed method.</p></sec><sec><title>Segmentation model and algorithm</title><sec><title>General segmentation model</title><p>The general segmentation problem consists in partitioning a signal of <italic>n</italic> data-points {<italic>y</italic><sub><italic>t</italic></sub>}<sub><italic>t</italic>&#x02208;[ [1,<italic>n</italic>] ]</sub> into a given number <italic>K</italic> of pieces or segments. The model can be written as follows: the observed data {<italic>y</italic><sub><italic>t</italic></sub>}<sub><italic>t</italic>=1,&#x02026;,<italic>n</italic></sub> are supposed to be a realization of an independent random process <italic>Y</italic>={<italic>Y</italic><sub><italic>t</italic></sub>}<sub><italic>t</italic>=1,&#x02026;,<italic>n</italic></sub>. This process is drawn from a probability distribution <inline-formula><inline-graphic xlink:href="1748-7188-9-6-i1.gif"/></inline-formula> which depends on a set of parameters among which one parameter <italic>&#x003b8;</italic> is assumed to be affected by <italic>K</italic>-1 abrupt changes, called change-points, such that </p><p><disp-formula><mml:math id="M1" name="1748-7188-9-6-i2" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>Y</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>~</mml:mo><mml:mi mathvariant="script">G</mml:mi><mml:mfenced open="(" close=")"><mml:msub><mml:mrow><mml:mi>&#x003b8;</mml:mi></mml:mrow><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>&#x003d5;</mml:mi></mml:mfenced><mml:mspace width="2em"/><mml:mtext>if</mml:mtext><mml:mspace width="1em"/><mml:mi>t</mml:mi><mml:mspace width="0.3em"/><mml:mo>&#x02208;</mml:mo><mml:mspace width="0.3em"/><mml:mi>r</mml:mi><mml:mspace width="1em"/><mml:mtext>and</mml:mtext><mml:mspace width="1em"/><mml:mi>r</mml:mi><mml:mo>&#x02208;</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:math></disp-formula></p><p> where <italic>m</italic> is a partition of [ [1,<italic>n</italic>] ] into segments <italic>r</italic>, <italic>&#x003b8;</italic><sub><italic>r</italic></sub> stands for the parameter of segment <italic>r</italic> and <italic>&#x003d5;</italic> is constant. The objective is to estimate the change-points or the positions of the segments and the parameters <italic>&#x003b8;</italic><sub><italic>r</italic></sub> both resulting from the segmentation. More precisely, we define <inline-formula><mml:math id="M2" name="1748-7188-9-6-i3" overflow="scroll"><mml:msub><mml:mrow><mml:mi mathvariant="script">&#x02133;</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> the set of all possible partitions in <italic>k</italic>&#x0003e;0 regions of the sequence up to point <italic>t</italic>. We recall that the number of possible partitions is </p><p><disp-formula><mml:math id="M3" name="1748-7188-9-6-i4" overflow="scroll"><mml:mrow><mml:mtext>card</mml:mtext><mml:mspace width="0.1em"/><mml:mfenced open="(" close=")"><mml:msub><mml:mrow><mml:mi mathvariant="script">&#x02133;</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi></mml:mrow></mml:msub></mml:mfenced><mml:mo>=</mml:mo><mml:mfenced open="(" close=")"><mml:mfrac linethickness="0"><mml:mrow><mml:mi>t</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfrac></mml:mfenced><mml:mi>.</mml:mi></mml:mrow></mml:math></disp-formula></p><p> We aim at choosing the partition in <inline-formula><mml:math id="M4" name="1748-7188-9-6-i5" overflow="scroll"><mml:msub><mml:mrow><mml:mi mathvariant="script">&#x02133;</mml:mi></mml:mrow><mml:mrow><mml:mi>K</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> of minimal loss <italic>&#x003b3;</italic>, where the loss is usually taken as the negative log-likelihood of the model. We define the point-additive loss of a segment with given parameter <italic>&#x003b8;</italic> as <inline-formula><mml:math id="M5" name="1748-7188-9-6-i6" overflow="scroll"><mml:mi>c</mml:mi><mml:mfenced open="(" close=")"><mml:mi>r</mml:mi><mml:mo>,</mml:mo><mml:mi>&#x003b8;</mml:mi></mml:mfenced><mml:mo>=</mml:mo><mml:munder><mml:mrow><mml:mo mathsize="big">&#x02211;</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mspace width="1em"/><mml:mo>&#x02208;</mml:mo><mml:mspace width="1em"/><mml:mi>r</mml:mi></mml:mrow></mml:munder><mml:mi>&#x003b3;</mml:mi><mml:mfenced open="(" close=")"><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>&#x003b8;</mml:mi></mml:mfenced></mml:math></inline-formula>, therefore its optimal cost is <italic>c</italic>(<italic>r</italic>)= min<italic>&#x003b8;</italic>{<italic>c</italic>(<italic>r</italic>,<italic>&#x003b8;</italic>)}. This allows us to define the cost of a segmentation <italic>m</italic> as <inline-formula><mml:math id="M6" name="1748-7188-9-6-i7" overflow="scroll"><mml:munder><mml:mrow><mml:mo mathsize="big">&#x02211;</mml:mo></mml:mrow><mml:mrow><mml:mi>r</mml:mi><mml:mspace width="1em"/><mml:mo>&#x02208;</mml:mo><mml:mspace width="1em"/><mml:mi>m</mml:mi></mml:mrow></mml:munder><mml:mi>c</mml:mi><mml:mo>(</mml:mo><mml:mi>r</mml:mi><mml:mo>)</mml:mo></mml:math></inline-formula> and our goal is to recover the optimal segmentation <italic>M</italic><sub><italic>K</italic>,<italic>n</italic></sub> and its cost <italic>C</italic><sub><italic>K</italic>,<italic>n</italic></sub> which are particular cases of the generic optimal segmentation of the signal up to point <italic>t</italic> in <italic>k</italic> segments and its cost, defined as: </p><p><disp-formula><mml:math id="M7" name="1748-7188-9-6-i8" overflow="scroll"><mml:mtable class="eqnarray" columnalign="left center right"><mml:mtr><mml:mtd><mml:mspace width="2em"/><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mo>arg</mml:mo><mml:mo>min</mml:mo></mml:mrow><mml:mrow><mml:mfenced open="{" close="}"><mml:mi>m</mml:mi><mml:mspace width="0.3em"/><mml:mo>&#x02208;</mml:mo><mml:mspace width="0.3em"/><mml:msub><mml:mrow><mml:mi mathvariant="script">&#x02133;</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi></mml:mrow></mml:msub></mml:mfenced></mml:mrow></mml:msub><mml:mfenced open="{" close="}"><mml:mrow><mml:munder accentunder="true"><mml:mrow><mml:mi mathsize="big">&#x02211;</mml:mi></mml:mrow><mml:mrow><mml:mi>r</mml:mi><mml:mspace width="0.3em"/><mml:mo>&#x02208;</mml:mo><mml:mspace width="0.3em"/><mml:mi>m</mml:mi></mml:mrow></mml:munder><mml:mi>c</mml:mi><mml:mfenced open="(" close=")"><mml:mi>r</mml:mi></mml:mfenced></mml:mrow></mml:mfenced></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mtext>and</mml:mtext><mml:mspace width="1em"/><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mtext>min</mml:mtext></mml:mrow><mml:mrow><mml:mfenced open="{" close="}"><mml:mi>m</mml:mi><mml:mspace width="0.3em"/><mml:mo>&#x02208;</mml:mo><mml:mspace width="0.3em"/><mml:msub><mml:mrow><mml:mi mathvariant="script">&#x02133;</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi></mml:mrow></mml:msub></mml:mfenced></mml:mrow></mml:msub><mml:mfenced open="{" close="}"><mml:mrow><mml:munder accentunder="true"><mml:mrow><mml:mi mathsize="big">&#x02211;</mml:mi></mml:mrow><mml:mrow><mml:mi>r</mml:mi><mml:mspace width="0.3em"/><mml:mo>&#x02208;</mml:mo><mml:mspace width="0.3em"/><mml:mi>m</mml:mi></mml:mrow></mml:munder><mml:mi>c</mml:mi><mml:mspace width="0.3em"/><mml:mfenced open="(" close=")"><mml:mi>r</mml:mi></mml:mfenced></mml:mrow></mml:mfenced><mml:mi>.</mml:mi></mml:mtd><mml:mtd><mml:mtext/></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula></p></sec><sec><title>Quick overview of the PDP algorithm</title><p>Like the original DP algorithm, the pruned DP algorithm is an iterative algorithm based on the minimization of a cost function <italic>C</italic><sub><italic>k</italic>,<italic>t</italic></sub> which is traditionally decomposed as: </p><p><disp-formula id="bmcM1"><label>(1)</label><mml:math id="M8" name="1748-7188-9-6-i9" overflow="scroll"><mml:mtable class="eqnarray" columnalign="left center right"><mml:mtr><mml:mtd class="eqnarray-1"><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:munder accentunder="true"><mml:mrow><mml:mi>min</mml:mi></mml:mrow><mml:mrow><mml:mfenced open="{" close="}"><mml:mi>k</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>&#x0003c;</mml:mo><mml:mi>&#x003c4;</mml:mi><mml:mo>&#x0003c;</mml:mo><mml:mi>t</mml:mi></mml:mfenced></mml:mrow></mml:munder><mml:mfenced open="{" close="}"><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>&#x003c4;</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:munder><mml:mrow><mml:mo>min</mml:mo></mml:mrow><mml:mrow><mml:mi>&#x003b8;</mml:mi></mml:mrow></mml:munder><mml:mfenced open="[" close="]"><mml:mrow><mml:mi>c</mml:mi><mml:mfenced open="(" close=")"><mml:mfenced open="[" close="]"><mml:mspace width="0.3em"/><mml:mi>&#x003c4;</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>t</mml:mi></mml:mfenced><mml:mspace width="0.3em"/><mml:mo>,</mml:mo><mml:mi>&#x003b8;</mml:mi></mml:mfenced></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula></p><p>where <italic>&#x003b8;</italic> is the parameter of the cost of the last segment, constraints on its possible values being directly related to the support of the loss function <italic>&#x003b3;</italic> (for instance <italic>&#x003b8;</italic> takes its value in <inline-formula><inline-graphic xlink:href="1748-7188-9-6-i10.gif"/></inline-formula> in the case of the Gaussian loss, but in [ 0,1] in the case of the binomial loss). In what follows we will denote by <italic>I</italic><sub><italic>s</italic></sub> the set of possible values for parameter <italic>&#x003b8;</italic>.</p><p>The specificity of the PDP algorithm is that it relies on the comparison of candidates for the last change-point position <italic>&#x003c4;</italic> through the permutation of the minimizations in (1) and the introduction of the functions: </p><p><disp-formula><mml:math id="M9" name="1748-7188-9-6-i11" overflow="scroll"><mml:mtable class="eqnarray" columnalign="left center right"><mml:mtr><mml:mtd class="eqnarray-1"><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mfenced open="(" close=")"><mml:mi>&#x003b8;</mml:mi></mml:mfenced><mml:mo>=</mml:mo><mml:munder accentunder="true"><mml:mrow><mml:mi>min</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>&#x0003c;</mml:mo><mml:mi>&#x003c4;</mml:mi><mml:mo>&#x02264;</mml:mo><mml:mi>t</mml:mi></mml:mrow></mml:munder><mml:mfenced open="{" close="}"><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>&#x003c4;</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mspace width="1em"/><mml:mi>c</mml:mi><mml:mfenced open="(" close=")"><mml:mfenced open="[" close="]"><mml:mspace width="0.3em"/><mml:mi>&#x003c4;</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>t</mml:mi></mml:mfenced><mml:mspace width="0.3em"/><mml:mo>,</mml:mo><mml:mi>&#x003b8;</mml:mi></mml:mfenced></mml:mrow></mml:mfenced><mml:mo>,</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula></p><p>which are the cost of the best partition in <italic>k</italic> regions up to <italic>t</italic>, the parameter of the last segment being <italic>&#x003b8;</italic>. <italic>C</italic><sub><italic>k</italic>,<italic>t</italic></sub> is then obtained as min<italic>&#x003b8;</italic>{<italic>H</italic><sub><italic>k</italic>,<italic>t</italic></sub>(<italic>&#x003b8;</italic>)}.</p><p>Then at each iteration <italic>k</italic>, the PDP algorithm works on a list of last change-point candidates: ListCandidate<sub><italic>k</italic></sub>. For each of these <italic>&#x003c4;</italic>s and for each value of <italic>t</italic>, it updates the set of <italic>&#x003b8;</italic>s, denoted <inline-formula><mml:math id="M10" name="1748-7188-9-6-i12" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>&#x003c4;</mml:mi></mml:mrow></mml:msubsup></mml:math></inline-formula> for which this candidate is optimal. If this set is empty, the candidate is discarded, resulting in the pruning and lower complexity of the algorithm.</p><p>The foundations of the algorithm can be written as follows. </p><p>&#x02022; Defining <inline-formula><mml:math id="M11" name="1748-7188-9-6-i13" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>&#x003c4;</mml:mi></mml:mrow></mml:msubsup><mml:mfenced open="(" close=")"><mml:mi>&#x003b8;</mml:mi></mml:mfenced><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>&#x003c4;</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msubsup><mml:mrow><mml:mo mathsize="big">&#x02211;</mml:mo></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mi>&#x003c4;</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:msubsup><mml:mi>&#x003b3;</mml:mi><mml:mspace width="0.1em"/><mml:mfenced open="(" close=")"><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>&#x003b8;</mml:mi></mml:mfenced></mml:math></inline-formula> the optimal cost if the last change is <italic>&#x003c4;</italic> and last parameter is <italic>&#x003b8;</italic>, then </p><p>(i) <inline-formula><mml:math id="M12" name="1748-7188-9-6-i14" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>&#x003c4;</mml:mi></mml:mrow></mml:msubsup><mml:mfenced open="(" close=")"><mml:mi>&#x003b8;</mml:mi></mml:mfenced></mml:math></inline-formula> is obtained from <inline-formula><mml:math id="M13" name="1748-7188-9-6-i15" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>&#x003c4;</mml:mi></mml:mrow></mml:msubsup><mml:mfenced open="(" close=")"><mml:mi>&#x003b8;</mml:mi></mml:mfenced></mml:math></inline-formula> using: </p><p><disp-formula><mml:math id="M14" name="1748-7188-9-6-i16" overflow="scroll"><mml:mtable class="eqnarray" columnalign="center"><mml:mtr><mml:mtd><mml:mspace width="7em"/><mml:msubsup><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>&#x003c4;</mml:mi></mml:mrow></mml:msubsup><mml:mfenced open="(" close=")"><mml:mi>&#x003b8;</mml:mi></mml:mfenced><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>&#x003c4;</mml:mi></mml:mrow></mml:msubsup><mml:mfenced open="(" close=")"><mml:mi>&#x003b8;</mml:mi></mml:mfenced><mml:mo>+</mml:mo><mml:mfenced open="(" close=")"><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>&#x003b8;</mml:mi></mml:mfenced><mml:mo>;</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula></p><p>&#x02022; Defining <inline-formula><mml:math id="M15" name="1748-7188-9-6-i17" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>&#x003c4;</mml:mi></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mfenced open="{" close="}"><mml:mrow><mml:mi>&#x003b8;</mml:mi><mml:mspace width="0.5em"/><mml:mo>|</mml:mo><mml:mspace width="0.5em"/><mml:msubsup><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>&#x003c4;</mml:mi></mml:mrow></mml:msubsup><mml:mfenced open="(" close=")"><mml:mi>&#x003b8;</mml:mi></mml:mfenced><mml:mspace width="0.5em"/><mml:mo>&#x02264;</mml:mo><mml:mspace width="0.5em"/><mml:msubsup><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:msubsup><mml:mfenced open="(" close=")"><mml:mi>&#x003b8;</mml:mi></mml:mfenced><mml:mspace width="1em"/></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mfenced open="{" close="}"><mml:mrow><mml:mi>&#x003b8;</mml:mi><mml:mspace width="0.5em"/><mml:mo>|</mml:mo><mml:mspace width="0.5em"/><mml:msubsup><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>&#x003c4;</mml:mi></mml:mrow></mml:msubsup><mml:mfenced open="(" close=")"><mml:mi>&#x003b8;</mml:mi></mml:mfenced><mml:mspace width="0.5em"/><mml:mo>&#x02264;</mml:mo><mml:mspace width="0.5em"/><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mspace width="1em"/></mml:mrow></mml:mfenced></mml:math></inline-formula> the set of <italic>&#x003b8;</italic> such that <italic>&#x003c4;</italic> is better than <italic>t</italic> in terms of cost, with <italic>&#x003c4;</italic>&#x0003c;<italic>t</italic>, then </p><p>(ii) if all <inline-formula><mml:math id="M16" name="1748-7188-9-6-i18" overflow="scroll"><mml:msubsup><mml:mrow><mml:mo mathsize="big">&#x02211;</mml:mo></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mi>&#x003c4;</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:msubsup><mml:mi>&#x003b3;</mml:mi><mml:mspace width="0.1em"/><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>&#x003b8;</mml:mi><mml:mo>)</mml:mo></mml:math></inline-formula> are unimodal in <italic>&#x003b8;</italic> then <inline-formula><mml:math id="M17" name="1748-7188-9-6-i19" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>&#x003c4;</mml:mi></mml:mrow></mml:msubsup></mml:math></inline-formula> are intervals. Indeed, since by definition <inline-formula><mml:math id="M18" name="1748-7188-9-6-i20" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:msubsup><mml:mo>(</mml:mo><mml:mi>&#x003b8;</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>t</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> and the cost function does not depend on <italic>&#x003b8;</italic>, <inline-formula><mml:math id="M19" name="1748-7188-9-6-i21" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>&#x003c4;</mml:mi></mml:mrow></mml:msubsup></mml:math></inline-formula> is the set of values for which a unimodal function is smaller than a constant.</p><p>&#x02022; Finally, we introduce <inline-formula><mml:math id="M20" name="1748-7188-9-6-i22" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>&#x003c4;</mml:mi></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mfenced open="{" close="}"><mml:mrow><mml:mi>&#x003b8;</mml:mi><mml:mspace width="0.5em"/><mml:mo>|</mml:mo><mml:mspace width="0.5em"/><mml:msubsup><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>&#x003c4;</mml:mi></mml:mrow></mml:msubsup><mml:mfenced open="(" close=")"><mml:mi>&#x003b8;</mml:mi></mml:mfenced><mml:mspace width="0.5em"/><mml:mo>&#x02264;</mml:mo><mml:mspace width="0.5em"/><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mfenced open="{" close="}"><mml:mi>&#x003b8;</mml:mi></mml:mfenced></mml:mrow></mml:mfenced></mml:math></inline-formula> the set of <italic>&#x003b8;</italic> such that <italic>&#x003c4;</italic> is optimal. Then since <inline-formula><mml:math id="M21" name="1748-7188-9-6-i23" overflow="scroll"><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mi>&#x003b8;</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:munder><mml:mrow><mml:mo>min</mml:mo></mml:mrow><mml:mrow><mml:mi>&#x003c4;</mml:mi><mml:mo>&#x02264;</mml:mo><mml:mi>t</mml:mi></mml:mrow></mml:munder><mml:mfenced open="{" close="}"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>&#x003c4;</mml:mi></mml:mrow></mml:msubsup><mml:mo>(</mml:mo><mml:mi>&#x003b8;</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mfenced></mml:math></inline-formula>, <inline-formula><mml:math id="M22" name="1748-7188-9-6-i24" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>&#x003c4;</mml:mi></mml:mrow></mml:msubsup></mml:math></inline-formula> can be written as <inline-formula><mml:math id="M23" name="1748-7188-9-6-i25" overflow="scroll"><mml:mfenced open="{" close="}"><mml:mrow><mml:mi>&#x003b8;</mml:mi><mml:mspace width="1em"/><mml:mo>|</mml:mo><mml:mspace width="1em"/><mml:msubsup><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>&#x003c4;</mml:mi></mml:mrow></mml:msubsup><mml:mo>(</mml:mo><mml:mi>&#x003b8;</mml:mi><mml:mo>)</mml:mo><mml:mspace width="1em"/><mml:mo>=</mml:mo><mml:mspace width="1em"/><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mi>&#x003b8;</mml:mi><mml:mo>)</mml:mo><mml:mspace width="1em"/></mml:mrow></mml:mfenced></mml:math></inline-formula> and we obtain that </p><p>(iii) <inline-formula><mml:math id="M24" name="1748-7188-9-6-i26" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>&#x003c4;</mml:mi></mml:mrow></mml:msubsup></mml:math></inline-formula> can be updated using: </p><p>&#x022c6; <inline-formula><mml:math id="M25" name="1748-7188-9-6-i27" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>&#x003c4;</mml:mi></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>&#x003c4;</mml:mi></mml:mrow></mml:msubsup><mml:mspace width="1em"/><mml:mo>&#x02229;</mml:mo><mml:msubsup><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>&#x003c4;</mml:mi></mml:mrow></mml:msubsup></mml:math></inline-formula></p><p>&#x022c6; <inline-formula><mml:math id="M26" name="1748-7188-9-6-i28" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi></mml:mrow></mml:msub><mml:mo>&#x02216;</mml:mo><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mo>&#x0222a;</mml:mo></mml:mrow><mml:mrow><mml:mi>&#x003c4;</mml:mi><mml:mo>&#x02208;</mml:mo><mml:msub><mml:mrow><mml:mtext>ListCandidate</mml:mtext></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:msubsup><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>&#x003c4;</mml:mi></mml:mrow></mml:msubsup><mml:mo>)</mml:mo></mml:math></inline-formula></p><p>The first assertion follows from the fact that <inline-formula><mml:math id="M27" name="1748-7188-9-6-i29" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>&#x003c4;</mml:mi></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mfenced open="{" close="}"><mml:mrow><mml:mi>&#x003b8;</mml:mi><mml:mo>|</mml:mo><mml:msubsup><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>&#x003c4;</mml:mi></mml:mrow></mml:msubsup><mml:mo>&#x02264;</mml:mo><mml:munder><mml:mrow><mml:mo>min</mml:mo></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>&#x02264;</mml:mo><mml:mi>&#x003c4;</mml:mi><mml:mo>&#x02264;</mml:mo><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munder><mml:msubsup><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>&#x003c4;</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mfenced open="{" close="}"><mml:mrow><mml:mi>&#x003b8;</mml:mi><mml:mo>|</mml:mo><mml:msubsup><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>&#x003c4;</mml:mi></mml:mrow></mml:msubsup><mml:mo>&#x02264;</mml:mo><mml:mo>min</mml:mo><mml:mfenced open="(" close=")"><mml:mrow><mml:munderover accentunder="false" accent="false"><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:mo>,</mml:mo><mml:munder><mml:mrow><mml:mo>min</mml:mo></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>&#x02264;</mml:mo><mml:mi>&#x003c4;</mml:mi><mml:mo>&#x02264;</mml:mo><mml:mi>t</mml:mi></mml:mrow></mml:munder><mml:msubsup><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>&#x003c4;</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced><mml:mo>,</mml:mo></mml:math></inline-formula> the first term in the minimum giving <inline-formula><mml:math id="M28" name="1748-7188-9-6-i30" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>&#x003c4;</mml:mi></mml:mrow></mml:msubsup></mml:math></inline-formula> and the second one giving <inline-formula><mml:math id="M29" name="1748-7188-9-6-i31" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>&#x003c4;</mml:mi></mml:mrow></mml:msubsup></mml:math></inline-formula>. The second assertion trivially follows from the fact that candidate <italic>t</italic> is optimal on the set of values where no other candidate was optimal.</p><p>&#x02022; </p><p>(iv) once it has been determined that <inline-formula><mml:math id="M30" name="1748-7188-9-6-i32" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>&#x003c4;</mml:mi></mml:mrow></mml:msubsup></mml:math></inline-formula> is empty, it easily follows from the update equation (<italic>i</italic><italic>i</italic><italic>i</italic>) that the region-border <italic>&#x003c4;</italic> can be discarded from the list of candidates <italic>L</italic><italic>i</italic><italic>s</italic><italic>t</italic><italic>C</italic><italic>a</italic><italic>n</italic><italic>d</italic><italic>i</italic><italic>d</italic><italic>a</italic><italic>t</italic><italic>e</italic><sub><italic>k</italic></sub>: </p><p><disp-formula><mml:math id="M31" name="1748-7188-9-6-i33" overflow="scroll"><mml:mtable class="eqnarray" columnalign="left center right"><mml:mtr><mml:mtd class="eqnarray-1"/><mml:mtd class="eqnarray-2"><mml:msubsup><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>&#x003c4;</mml:mi></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mi>&#x02205;</mml:mi></mml:mtd><mml:mtd class="eqnarray-3"><mml:mo>&#x021d2;</mml:mo><mml:mspace width="2em"/><mml:mo>&#x02200;</mml:mo><mml:mspace width="1em"/><mml:msup><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mo>&#x02032;</mml:mo></mml:mrow></mml:msup><mml:mo>&#x02265;</mml:mo><mml:mi>t</mml:mi><mml:mspace width="1em"/><mml:msubsup><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mo>&#x02032;</mml:mo></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mi>&#x003c4;</mml:mi></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mi>&#x02205;.</mml:mi></mml:mtd><mml:mtd><mml:mtext/></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula></p><sec><title/><sec><title>Requirements of the pruned dynamic programming algorithm</title><sec><title>Proposition 0.1</title><p>Properties (<italic>i</italic>) to (<italic>iv</italic>) are satisfied as soon as the following conditions on the loss <italic>c</italic>(<italic>r</italic>,<italic>&#x003b8;</italic>) are met: </p><p>(a) It is point additive,</p><p>(b) It is convex with respect to its parameter <italic>&#x003b8;</italic>,</p><p>(c) It can be stored and updated efficiently.</p><p>The proof of those claims can be found in [<xref ref-type="bibr" rid="B18">18</xref>]. A pseudo-code of the PDP algorithm is given in the appendix.</p><p>It is possible to include an additional penalty term, denoted <italic>g</italic> as in the pseudo-code, in the loss function. To preserve the point-additivity requirement of the loss, this penalty can only depend on the value of the segment-parameter <italic>&#x003b8;</italic> and not on any other characteristics, such as segment length. This is then equivalent to minimizing <italic>C</italic><sub><italic>k</italic>,<italic>t</italic></sub>= min{<italic>k</italic>-1&#x0003c;<italic>&#x003c4;</italic>&#x0003c;<italic>t</italic>}{<italic>C</italic><sub><italic>k</italic>-1,<italic>&#x003c4;</italic></sub>+ min<italic>&#x003b8;</italic>{<italic>c</italic>([ <italic>&#x003c4;</italic>+1,<italic>t</italic>],<italic>&#x003b8;</italic>)+<italic>g</italic>(<italic>&#x003b8;</italic>)}} and can be achieved by adding the penalty value <italic>g</italic>(<italic>&#x003b8;</italic>) in the initialization of <inline-formula><mml:math id="M32" name="1748-7188-9-6-i34" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>&#x003c4;</mml:mi></mml:mrow></mml:msubsup><mml:mo>(</mml:mo><mml:mi>&#x003b8;</mml:mi><mml:mo>)</mml:mo></mml:math></inline-formula>. For example, in the case of RNA-seq data one could add a lasso (<italic>&#x003bb;</italic>|<italic>&#x003b8;</italic>|) or ridge penalty (<italic>&#x003bb;</italic><italic>&#x003b8;</italic><sup>2</sup>) to encode that <italic>a priori</italic> the coverage in most regions should be close to 0. Our C++ implementation of the PDP algorithm includes the possibility of adding such a penalty term; however we do not provide an <monospace>R</monospace> interface to this functionality in our <monospace>R</monospace> package. One of the reasons for this choice is that choosing an appropriate value for <italic>&#x003bb;</italic> is not a simple problem.</p></sec></sec></sec></sec></sec><sec><title>Contribution</title><sec><title>Pruned dynamic programming algorithm for count data</title><p>We now show that the PDP algorithm can be applied to the segmentation of RNA-Seq data using a negative binomial model and we propose a criterion for the choice of <italic>K</italic>. Though not discussed here, our results also hold for the Poisson segmentation model.</p><sec><title/><sec><title>Negative binomial model</title><p>We consider that in each segment <italic>r</italic> all <italic>y</italic><sub><italic>t</italic></sub> are the realization of random variables <italic>Y</italic><sub><italic>t</italic></sub> which are independent and follow the same negative binomial distribution. Assuming the dispersion parameter <italic>&#x003d5;</italic> to be known, we will use the natural parametrization from the exponential family (also classically used in <italic>R</italic>) so that parameter <italic>&#x003b8;</italic><sub><italic>r</italic></sub> will be the probability of success. In this framework, <italic>&#x003b8;</italic><sub><italic>r</italic></sub> is specific to segment <italic>r</italic> whereas <italic>&#x003d5;</italic> is common to all segments.</p><p>We have <italic>E</italic>(<italic>Y</italic><sub><italic>t</italic></sub>)=<italic>&#x003d5;</italic>(1-<italic>&#x003b8;</italic>)/<italic>&#x003b8;</italic> and <italic>V</italic><italic>a</italic><italic>r</italic>(<italic>Y</italic><sub><italic>t</italic></sub>)=<italic>&#x003d5;</italic>(1-<italic>&#x003b8;</italic>)/<italic>&#x003b8;</italic><sup>2</sup>. We choose the loss as the negative log-likelihood associated with data-point <italic>t</italic> belonging to segment <italic>r</italic>: -<italic>&#x003d5;</italic> log(<italic>&#x003b8;</italic><sub><italic>r</italic></sub>)-<italic>y</italic><sub><italic>t</italic></sub> log(1-<italic>&#x003b8;</italic><sub><italic>r</italic></sub>)+<italic>A</italic>(<italic>&#x003d5;</italic>,<italic>y</italic><sub><italic>t</italic></sub>), or more simply <italic>&#x003b3;</italic>(<italic>y</italic><sub><italic>t</italic></sub>,<italic>&#x003b8;</italic><sub><italic>r</italic></sub>)=-<italic>&#x003d5;</italic> log(<italic>&#x003b8;</italic><sub><italic>r</italic></sub>)-<italic>y</italic><sub><italic>t</italic></sub> log(1-<italic>&#x003b8;</italic><sub><italic>r</italic></sub>) since <italic>A</italic> is a function that does not depend on <italic>&#x003b8;</italic><sub><italic>r</italic></sub>.</p></sec></sec><sec><title/><sec><title>Validity of the pruned dynamic programming algorithm for the negative binomial model</title><sec><title>Proposition 0.2</title><p>Assuming parameter <italic>&#x003d5;</italic> to be known, the negative binomial model satisfies (a), (b) and (c):</p><p>(a) As we assume that <italic>Y</italic><sub><italic>t</italic></sub> are independent, we indeed have that the loss is point additive: <inline-formula><mml:math id="M33" name="1748-7188-9-6-i35" overflow="scroll"><mml:mi>c</mml:mi><mml:mo>(</mml:mo><mml:mi>r</mml:mi><mml:mo>,</mml:mo><mml:mi>&#x003b8;</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:munder><mml:mrow><mml:mo mathsize="big">&#x02211;</mml:mo></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mspace width="1em"/><mml:mo>&#x02208;</mml:mo><mml:mspace width="1em"/><mml:mi>r</mml:mi></mml:mrow></mml:munder><mml:mi>&#x003b3;</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>&#x003b8;</mml:mi><mml:mo>)</mml:mo><mml:mi>.</mml:mi></mml:math></inline-formula></p><p>(b) As <italic>&#x003b3;</italic>(<italic>y</italic><sub><italic>t</italic></sub>,<italic>&#x003b8;</italic>)=-<italic>&#x003d5;</italic> log(<italic>&#x003b8;</italic>)-<italic>y</italic><sub><italic>t</italic></sub> log(1-<italic>&#x003b8;</italic>) is convex with respect to <italic>&#x003b8;</italic>, <italic>c</italic>(<italic>r</italic>,<italic>&#x003b8;</italic>) is also convex as the sum of convex functions.</p><p>(c) Finally, we have <inline-formula><mml:math id="M34" name="1748-7188-9-6-i36" overflow="scroll"><mml:mi>c</mml:mi><mml:mo>(</mml:mo><mml:mi>r</mml:mi><mml:mo>,</mml:mo><mml:mi>&#x003b8;</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mo>-</mml:mo><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:msub><mml:mi>&#x003d5;</mml:mi><mml:mo>log</mml:mo><mml:mo>(</mml:mo><mml:mi>&#x003b8;</mml:mi><mml:mo>)</mml:mo><mml:mo>+</mml:mo><mml:munder><mml:mrow><mml:mo mathsize="big">&#x02211;</mml:mo></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mspace width="1em"/><mml:mo>&#x02208;</mml:mo><mml:mspace width="1em"/><mml:mi>r</mml:mi></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>log</mml:mo><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>-</mml:mo><mml:mi>&#x003b8;</mml:mi><mml:mo>)</mml:mo></mml:math></inline-formula> (where <italic>n</italic><sub><italic>r</italic></sub> is the length of segment <italic>r</italic>). This function can be stored and updated using only two doubles: one for -<italic>n</italic><sub><italic>r</italic></sub><italic>&#x003d5;</italic>, say <italic>d</italic><sub>1</sub>, and the other for <inline-formula><mml:math id="M35" name="1748-7188-9-6-i37" overflow="scroll"><mml:munder><mml:mrow><mml:mo mathsize="big">&#x02211;</mml:mo></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mspace width="1em"/><mml:mo>&#x02208;</mml:mo><mml:mspace width="1em"/><mml:mi>r</mml:mi></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula>, say <italic>d</italic><sub>2</sub>. Then at step <italic>t</italic>+1 as the new datapoint <italic>y</italic><sub><italic>t</italic>+1</sub> is considered, these doubles are simply updated as <italic>d</italic><sub>1</sub>&#x02190;<italic>d</italic><sub>1</sub>+<italic>&#x003d5;</italic> and <italic>d</italic><sub>2</sub>&#x02190;<italic>d</italic><sub>2</sub>+<italic>y</italic><sub><italic>t</italic>+1</sub>.</p></sec></sec></sec><sec><title/><sec><title>Estimation of the overdispersion parameter</title><p>We propose to estimate <italic>&#x003d5;</italic> using a modified version of Johnson <italic>et. al</italic>&#x02019;s estimator [<xref ref-type="bibr" rid="B19">19</xref>]: compute the moment estimator of <italic>&#x003d5;</italic> on each sliding window of size <italic>h</italic> using the formula <inline-formula><mml:math id="M36" name="1748-7188-9-6-i38" overflow="scroll"><mml:mi>&#x003d5;</mml:mi><mml:mo>=</mml:mo><mml:mi mathvariant="double-struck">E</mml:mi><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mi>Y</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>/</mml:mo><mml:mo>(</mml:mo><mml:mtext mathvariant="italic">Var</mml:mtext><mml:mo>(</mml:mo><mml:mi>Y</mml:mi><mml:mo>)</mml:mo><mml:mo>-</mml:mo><mml:mi mathvariant="double-struck">E</mml:mi><mml:mo>(</mml:mo><mml:mi>Y</mml:mi><mml:mo>)</mml:mo><mml:mo>)</mml:mo></mml:math></inline-formula> and keep the median <inline-formula><mml:math id="M37" name="1748-7188-9-6-i39" overflow="scroll"><mml:mover accent="false"><mml:mrow><mml:mi>&#x003d5;</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover></mml:math></inline-formula>.</p></sec></sec><sec><title/><sec><title>Taking into account a positional bias</title><p>It is possible that the assumption that the counts share the same distribution in a segment might not be verified. For instance in the case of RNA-Seq data the number of reads can be affected by the location in the transcribed region or by the GC-content of the fragment. The pruned dynamic programming algorithm only requires a vector of integers as input, it is therefore possible to apply any kind of normalization process that preserves the count-specificity of the data prior to segmentation. For instance, a method such as that which has resulted in the publication of the data used in the illustration [<xref ref-type="bibr" rid="B20">20</xref>] can be applied. A comparison of the main normalization methods can for example be found in Bullard <italic>et. al.</italic>&#x02019;s paper [<xref ref-type="bibr" rid="B21">21</xref>].</p></sec></sec></sec><sec><title>C++ implementation of the PDP algorithm</title><p>We implemented the PDP algorithm in C++ having in mind the possibility of adding new loss functions in potential future applications. The difficulties we had to face were the versatility of the program to be designed and the design of the objects it could work on. Indeed, the use of full templates implied that we used stable sets of objects for the operations that were to be performed.</p><p>Namely: </p><p>&#x02022; The sets were to be chosen in a <italic>tribe</italic>. This means that they all belong to a set<inline-formula><mml:math id="M38" name="1748-7188-9-6-i40" overflow="scroll"><mml:mrow><mml:mo>&#x0200a;</mml:mo><mml:mi mathvariant="script">S</mml:mi></mml:mrow></mml:math></inline-formula> of sets such that any set <inline-formula><mml:math id="M39" name="1748-7188-9-6-i41" overflow="scroll"><mml:mi>s</mml:mi><mml:mo>&#x02208;</mml:mo><mml:mi mathvariant="script">S</mml:mi></mml:math></inline-formula> can be conveniently handled and stored in the computer. A set of sets<inline-formula><mml:math id="M40" name="1748-7188-9-6-i42" overflow="scroll"><mml:mrow><mml:mo>&#x0200a;</mml:mo><mml:mi mathvariant="script">S</mml:mi></mml:mrow></mml:math></inline-formula> is said to be <italic>acceptable</italic> if it satisfies the following: </p><p>1. If <italic>s</italic> belongs to<inline-formula><mml:math id="M41" name="1748-7188-9-6-i43" overflow="scroll"><mml:mrow><mml:mo>&#x0200a;</mml:mo><mml:mi mathvariant="script">S</mml:mi></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="M42" name="1748-7188-9-6-i44" overflow="scroll"><mml:mi mathvariant="double-struck">R</mml:mi><mml:mo>&#x02216;</mml:mo><mml:mi>s</mml:mi><mml:mo>&#x02208;</mml:mo><mml:mi mathvariant="script">S</mml:mi></mml:math></inline-formula></p><p>2. If <inline-formula><mml:math id="M43" name="1748-7188-9-6-i45" overflow="scroll"><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>&#x02208;</mml:mo><mml:mi mathvariant="script">S</mml:mi><mml:mo>,</mml:mo><mml:mspace width="0.3em"/><mml:mspace width="0.3em"/><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>&#x02229;</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>&#x02208;</mml:mo><mml:mi mathvariant="script">S</mml:mi></mml:math></inline-formula></p><p>3. If <inline-formula><mml:math id="M44" name="1748-7188-9-6-i46" overflow="scroll"><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>&#x02208;</mml:mo><mml:mi mathvariant="script">S</mml:mi><mml:mo>,</mml:mo><mml:mspace width="0.3em"/><mml:mspace width="0.3em"/><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>&#x0222a;</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>&#x02208;</mml:mo><mml:mi mathvariant="script">S</mml:mi></mml:math></inline-formula></p><p>&#x02022; For instance, the set<inline-formula><mml:math id="M45" name="1748-7188-9-6-i47" overflow="scroll"><mml:mo>&#x0200a;</mml:mo><mml:mi mathvariant="script">S</mml:mi></mml:math></inline-formula> of intervals is a tribe since the complementary, the union and the intersection of intervals form a union of intervals. This property ensures that the sets <inline-formula><mml:math id="M46" name="1748-7188-9-6-i48" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>&#x003c4;</mml:mi></mml:mrow></mml:msubsup></mml:math></inline-formula> and <inline-formula><mml:math id="M47" name="1748-7188-9-6-i49" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>&#x003c4;</mml:mi></mml:mrow></mml:msubsup></mml:math></inline-formula> can be updated and stored efficiently (only two doubles are required to store an interval) to take full advantage of the pruning process.</p><p>&#x02022; The cost functions were chosen in a set<inline-formula><mml:math id="M48" name="1748-7188-9-6-i50" overflow="scroll"><mml:mo>&#x0200a;</mml:mo><mml:mi mathvariant="script">F</mml:mi></mml:math></inline-formula> such that </p><p>1. Each function may be conveniently handled and stored by the software.</p><p>For instance, for the Gaussian loss it suffices to store the three coefficients of a second order polynomial.</p><p>2. For any <inline-formula><mml:math id="M49" name="1748-7188-9-6-i51" overflow="scroll"><mml:mi>f</mml:mi><mml:mo>&#x02208;</mml:mo><mml:mi mathvariant="script">F</mml:mi></mml:math></inline-formula> and any constant <italic>c</italic>, <italic>f</italic>(<italic>x</italic>)&#x02264;<italic>c</italic> can be easily solved and the set of solutions belongs to an acceptable set of sets</p><p>3. For any <inline-formula><mml:math id="M50" name="1748-7188-9-6-i52" overflow="scroll"><mml:mi>f</mml:mi><mml:mo>,</mml:mo><mml:mi>g</mml:mi><mml:mo>&#x02208;</mml:mo><mml:mi mathvariant="script">F</mml:mi><mml:mo>,</mml:mo><mml:mspace width="0.3em"/><mml:mi>f</mml:mi><mml:mo>+</mml:mo><mml:mi>g</mml:mi><mml:mo>&#x02208;</mml:mo><mml:mi mathvariant="script">F</mml:mi></mml:math></inline-formula>.</p><p>These two points ensure that the cost (and penalty) functions can be easily updated and compared so that the sets <inline-formula><mml:math id="M51" name="1748-7188-9-6-i53" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>&#x003c4;</mml:mi></mml:mrow></mml:msubsup></mml:math></inline-formula> of each candidate <italic>&#x003c4;</italic> can be updated and candidates eventually discarded.</p><p>Thus we defined two collections for the sets of sets<inline-formula><mml:math id="M52" name="1748-7188-9-6-i54" overflow="scroll"><mml:mo>&#x0200a;</mml:mo><mml:mi mathvariant="script">S</mml:mi></mml:math></inline-formula>, intervals and parallelepipeds, and implemented the loss functions corresponding to negative binomial, Poisson or normal distributions. The program is thus designed in a way that any user can add his own cost function or acceptable set of probability function and use it without rewriting a line in the code.</p></sec><sec><title>Compression of the signal</title><p>In the case of count data, and in particular in the analysis of RNA-Seq data, it is very likely that we observe plateaux, that is regions between two arbitrary positions <italic>t</italic><sub>1</sub> and <italic>t</italic><sub>2</sub> (&#x0003e;<italic>t</italic><sub>1</sub>) where the signal is constant: </p><p><disp-formula><mml:math id="M53" name="1748-7188-9-6-i55" overflow="scroll"><mml:mrow><mml:mo>&#x02200;</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mspace width="1em"/><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>&#x02264;</mml:mo><mml:mi>t</mml:mi><mml:mo>&#x02264;</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mspace width="1em"/><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mi>.</mml:mi></mml:mrow></mml:math></disp-formula> Then we have the following proposition, the proof of which is given in the appendix.</p><sec><title>Proposition 0.3</title><p>There exists a segmentation <italic>m</italic> in <italic>K</italic> or fewer segments without any change-point in the plateaux such that the optimal cost of <italic>m</italic> is equal to <italic>C</italic><sub><italic>K</italic>,<italic>n</italic></sub>.</p><p>This proposition proves the arguably intuitive idea that having a change-point between <italic>t</italic><sub>1</sub> and <italic>t</italic><sub>2</sub> is never beneficial in terms of cost. When searching for the best segmentation of the data, it is therefore unnecessary to look for change-points in plateaux. In other words a plateau starting at position <italic>t</italic><sub>1</sub> and ending at position <italic>t</italic><sub>2</sub> can be considered as a unique data point with value <inline-formula><mml:math id="M54" name="1748-7188-9-6-i56" overflow="scroll"><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub></mml:math></inline-formula> and weight <italic>t</italic><sub>2</sub>-<italic>t</italic><sub>1</sub>+1. At worst the size of the compressed signal is equal to the minimum between two times the number of reads and the length of the chromosome arm. Thus, if the number of reads is very large, the two-step algorithm (compression and pruned dynamic programming) does not change the worst case complexity. However, in most cases the number of reads is much smaller than the size of the considered chromosome. Thus compression is efficient and allows for a significant reduction in the overall run-time. Furthermore, in the case of RNA-Seq data we do not expect reads to be evenly scattered. On the contrary they are concentrated in transcribed regions and between those regions we expect large plateaux of 0 allowing for an efficient compression (for instance only 2% of the human chromosome contains coding regions).</p></sec></sec><sec><title>Model selection</title><p>The last issue concerns the estimate of the number of segments <italic>K</italic>. This model selection issue can be solved using a penalized log-likelihood criterion for which the choice of a good penalty function is crucial. This kind of procedure typically requires computation of the optimal segmentations in all <italic>k</italic>=1,&#x02026;,<italic>K</italic><sub>max</sub> segments where <italic>K</italic><sub>max</sub> is generally chosen smaller than <italic>n</italic>. The most popular criteria (AIC [<xref ref-type="bibr" rid="B22">22</xref>] and BIC [<xref ref-type="bibr" rid="B23">23</xref>]) failed in the segmentation context due to the discrete nature of the change-points. Indeed, additionally to being an asymptotic criterion in a framework where the collection of possible models grows polynomially with <italic>n</italic>, the BIC criterion uses a Laplace approximation requiring differentiability conditions of the likelihood function which are not satisfied by the segmentation model [<xref ref-type="bibr" rid="B24">24</xref>]. From a non-asymptotic point of view and for the negative binomial model, the following criterion was proposed [<xref ref-type="bibr" rid="B25">25</xref>]: denoting <inline-formula><mml:math id="M55" name="1748-7188-9-6-i57" overflow="scroll"><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>K</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> the optimal segmentation of the data in <italic>K</italic> segments, </p><p><disp-formula id="bmcM2"><label>(2)</label><mml:math id="M56" name="1748-7188-9-6-i58" overflow="scroll"><mml:mspace width="-16.0pt"/><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mover accent="true"><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mspace width="0.3em"/><mml:mo>=</mml:mo><mml:mspace width="2.77626pt"/><mml:munder accentunder="true"><mml:mrow><mml:mi>arg</mml:mi><mml:mspace width="0.5em"/><mml:mi>min</mml:mi></mml:mrow><mml:mrow><mml:mi>K</mml:mi><mml:mo>&#x02208;</mml:mo><mml:mn>1</mml:mn><mml:mo>:</mml:mo><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mo>max</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:munder><mml:mspace width="0.3em"/><mml:mspace width="0.3em"/><mml:mfenced open="{"><mml:mrow><mml:mspace width="0.3em"/><mml:munder accentunder="true"><mml:mrow><mml:mi mathsize="big">&#x02211;</mml:mi></mml:mrow><mml:mrow><mml:mi>r</mml:mi><mml:mo>&#x02208;</mml:mo><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>K</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:munder><mml:mspace width="0.3em"/><mml:munder accentunder="true"><mml:mrow><mml:mi mathsize="big">&#x02211;</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mo>&#x02208;</mml:mo><mml:mi>r</mml:mi></mml:mrow></mml:munder><mml:mspace width="0.3em"/><mml:mfenced open="[" close="]"><mml:mrow><mml:mo>-</mml:mo><mml:mi>&#x003d5;</mml:mi><mml:mtext>log</mml:mtext><mml:mfrac><mml:mrow><mml:mi>&#x003d5;</mml:mi></mml:mrow><mml:mrow><mml:mi>&#x003d5;</mml:mi><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mo>&#x000af;</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:mo>-</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>log</mml:mo><mml:mspace width="0.3em"/><mml:mfenced open="(" close=")"><mml:mrow><mml:mspace width="0.3em"/><mml:mn>1</mml:mn><mml:mo>-</mml:mo><mml:mfrac><mml:mrow><mml:mi>&#x003d5;</mml:mi></mml:mrow><mml:mrow><mml:mi>&#x003d5;</mml:mi><mml:mspace width="0.3em"/><mml:mo>+</mml:mo><mml:mspace width="0.3em"/><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mo>&#x000af;</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:mspace width="0.3em"/></mml:mrow></mml:mfenced><mml:mspace width="0.3em"/></mml:mrow></mml:mfenced><mml:mspace width="0.3em"/></mml:mrow></mml:mfenced></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mfenced close="}"><mml:mrow><mml:mspace width="3.5em"/><mml:mo>+</mml:mo><mml:mspace width="2.77626pt"/><mml:mi>&#x003b2;K</mml:mi><mml:mspace width="0.2em"/><mml:msup><mml:mrow><mml:mfenced open="(" close=")"><mml:mrow><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mn>4</mml:mn><mml:msqrt><mml:mrow><mml:mn>1.1</mml:mn><mml:mo>+</mml:mo><mml:mo>log</mml:mo><mml:mfenced open="(" close=")"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>K</mml:mi></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced></mml:mrow></mml:msqrt></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced><mml:mo>,</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula></p><p>where <inline-formula><mml:math id="M57" name="1748-7188-9-6-i59" overflow="scroll"><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mo>&#x000af;</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:munder><mml:mrow><mml:mo mathsize="big">&#x02211;</mml:mo></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mo>&#x02208;</mml:mo><mml:mi>r</mml:mi></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac></mml:math></inline-formula> and <inline-formula><mml:math id="M58" name="1748-7188-9-6-i60" overflow="scroll"><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> is the size of segment <italic>r</italic>. The first term corresponds to the cost of the optimal segmentation while the second is a penalty term which depends on the dimension <italic>K</italic> and on a constant <italic>&#x003b2;</italic> that has to be tuned according to the data (see the next section). With this choice of penalty, a so-called oracle penalty, the resulting estimator satisfies an oracle-type inequality. A more complete performance study is done in [<xref ref-type="bibr" rid="B25">25</xref>] and showed that the proposed criterion outperforms the existing ones.</p></sec></sec><sec><title>Implementation</title><p>The Pruned Dynamic Programming algorithm is available in the function <monospace>Segmentor</monospace> of the <italic>R</italic> package <bold>Segmentor3IsBack</bold>. Version 1.7 of this package contains the compression process which is performed by default in the case of count data. The user can choose the distribution with the slot <monospace>model</monospace> (1 for Poisson, 2 for Gaussian homoscedastic, 3 for negative binomial and 4 for segmentation of the variance). It returns an S4 object of class Segmentor which can later be processed for other purposes. The function <monospace>SelectModel</monospace> provides four criteria for choosing the optimal number of segments: AIC [<xref ref-type="bibr" rid="B22">22</xref>], BIC [<xref ref-type="bibr" rid="B23">23</xref>], the modified BIC [<xref ref-type="bibr" rid="B24">24</xref>] (available for Gaussian and Poisson distribution) and oracle penalties (available for the Gaussian distribution [<xref ref-type="bibr" rid="B26">26</xref>] and for the Poisson and negative binomial [<xref ref-type="bibr" rid="B25">25</xref>] as described previously). This latter kind of penalty requires tuning a constant according to the data, which is done using the slope heuristic [<xref ref-type="bibr" rid="B27">27</xref>].</p><p>Figure <xref ref-type="fig" rid="F1">1</xref> (which is detailed in the Results and discussion Section) was obtained with the following 4 lines of code (assuming the data was contained in vector <monospace>x</monospace>):</p><fig id="F1" position="float"><label>Figure 1</label><caption><p><bold>Segmentation of the yeast chromosome 1 using the negative binomial loss.</bold> The model selection procedure chooses <italic>K</italic>=125 segments, most of which correspond to the official annotation, with segments corresponding to transcribed regions surrounding official genes.</p></caption><graphic xlink:href="1748-7188-9-6-1"/></fig><p><monospace>Seg&#x0003c;-Segmentor(x,model=3,Kmax=200)</monospace></p><p><monospace>Kchoose&#x0003c;-SelectModel(Seg, penalty=~oracle~)</monospace></p><p><monospace>plot(sqrt(x),col=&#x02019;dark red&#x02019;)</monospace></p><p><monospace>abline(v=getBreaks(Seg)[Kchoose, 1:Kchoose],col=&#x02019;blue&#x02019;)</monospace></p><p>The function <monospace>BestSegmentation</monospace> allows us, for a given <italic>K</italic>, to find the optimal segmentation with a change-point at location <italic>t</italic> (slot <monospace>$bestSeg</monospace>). It also provides, through the slot <monospace>$bestCost</monospace>, the cost of the optimal segmentation with <italic>t</italic> for <italic>j</italic><sup><italic>t</italic><italic>h</italic></sup> change-point. Figure <xref ref-type="fig" rid="F2">2</xref>(Left) illustrates this result for the optimal segmentations in 4 segments of a signal simulated with only 3 segments. We can see for instance that any choice of first change-point location between 1 and 2000 yields almost the same cost (the minimum is obtained for <italic>t</italic>=1481), and thus the optimal segmentation is not clearly better than the next best segmentations. On the contrary, the same function with 3 segments shows that the optimal segmentation outperforms all other segmentations in 3 segments.</p><fig id="F2" position="float"><label>Figure 2</label><caption><p><bold>Cost of optimal segmentation in 4 and 3 segments.</bold> Cost of optimal segmentation depending on the location of the <italic>j</italic><sup><italic>th</italic></sup> change-point when the number of segments is 4 (Left) and 3 (Right) and the signal was simulated with 3 segments. Illustration of the output of function <monospace>BestSegmentation</monospace>.</p></caption><graphic xlink:href="1748-7188-9-6-2"/></fig></sec><sec><title>Results and discussion</title><sec><title>Performance study</title><p>We designed a simulation study on the negative binomial distribution to assess the performance of the PDP algorithm in terms of computational efficiency without using the compression option, while studying the impact of the overdispersion parameter <italic>&#x003d5;</italic> by comparing the results for two different values of this parameter. After running different estimators (median on sliding windows of maximum, quasi-maximum likelihood and moment estimators) on several real RNA-Seq data (whole chromosome and genes of various sizes), we fixed <italic>&#x003d5;</italic><sub>1</sub>=0.3 as a typical value for highly dispersed data as observed in real RNA-Seq data and chose <italic>&#x003d5;</italic><sub>2</sub>=2.3 for comparison with a reasonably dispersed dataset. For each value, we simulated datasets of size <italic>n</italic> with various densities of number of segments <italic>K</italic>, and only two possible values for the parameter <italic>p</italic><sub><italic>J</italic></sub>: 0.8 on even segments (corresponding to low signal) and 0.2 on odd segments for a higher signal. We had <italic>n</italic> vary on a logarithmic scale between 10<sup>3</sup> and 10<sup>6</sup> and <italic>K</italic> between <inline-formula><mml:math id="M59" name="1748-7188-9-6-i61" overflow="scroll"><mml:msqrt><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msqrt><mml:mo>/</mml:mo><mml:mn>6</mml:mn></mml:math></inline-formula> and <inline-formula><mml:math id="M60" name="1748-7188-9-6-i62" overflow="scroll"><mml:msqrt><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msqrt><mml:mo>/</mml:mo><mml:mn>3</mml:mn></mml:math></inline-formula>. For each configuration, we segmented the signal up to <inline-formula><mml:math id="M61" name="1748-7188-9-6-i63" overflow="scroll"><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mo>max</mml:mo></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msqrt><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msqrt></mml:math></inline-formula> twice: once with the known value of <italic>&#x003d5;</italic> and once with our estimator <inline-formula><mml:math id="M62" name="1748-7188-9-6-i64" overflow="scroll"><mml:mover accent="false"><mml:mrow><mml:mi>&#x003d5;</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover></mml:math></inline-formula> as described above. We started with a window width <italic>h</italic>=15. When the estimate was negative, we doubled <italic>h</italic> and repeated the experience until the median was positive.</p><p>Each configuration was simulated 100 times.</p><p>For our analysis we checked the run-time on a standard laptop, and assessed the quality of the segmentation using the Rand Index <inline-formula><inline-graphic xlink:href="1748-7188-9-6-i65.gif"/></inline-formula>. Specifically, let <italic>C</italic><sub><italic>t</italic></sub> be the true index of the segment to which base <italic>t</italic> belongs and let <inline-formula><mml:math id="M63" name="1748-7188-9-6-i66" overflow="scroll"><mml:msub><mml:mrow><mml:mi>&#x00108;</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> be the index estimated by the method, then </p><p><disp-formula><mml:math id="M64" name="1748-7188-9-6-i67" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">I</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>2</mml:mn><mml:msubsup><mml:mrow><mml:mo mathsize="big">&#x02211;</mml:mo></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msubsup><mml:msub><mml:mrow><mml:mo mathsize="big">&#x02211;</mml:mo></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mo>&#x0003e;</mml:mo><mml:mi>s</mml:mi></mml:mrow></mml:msub><mml:mfenced open="[" close="]"><mml:mrow><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>&#x00108;</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>&#x00108;</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>&#x02260;</mml:mo><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>&#x00108;</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>&#x02260;</mml:mo><mml:msub><mml:mrow><mml:mi>&#x00108;</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mfrac><mml:mi>.</mml:mi></mml:mrow></mml:math></disp-formula></p><p>Figure <xref ref-type="fig" rid="F3">3</xref> shows, for the particular case of <inline-formula><mml:math id="M65" name="1748-7188-9-6-i68" overflow="scroll"><mml:mi>K</mml:mi><mml:mo>=</mml:mo><mml:msqrt><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msqrt><mml:mo>/</mml:mo><mml:mn>3</mml:mn></mml:math></inline-formula>, the almost linear complexity of the algorithm in the size <italic>n</italic> of the signal. As the maximal number of segments <italic>K</italic><sub>max</sub> considered increased with <italic>n</italic>, we normalized the run-time to allow comparison. This underlines an empirical complexity smaller than <inline-formula><mml:math id="M66" name="1748-7188-9-6-i69" overflow="scroll"><mml:mi mathvariant="script">O</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mo>max</mml:mo></mml:mrow></mml:msub><mml:mi>n</mml:mi><mml:mo>log</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math></inline-formula>, and independent of the value of <italic>&#x003d5;</italic> or its knowledge. Moreover, the algorithm, and therefore the pruning, is faster when the overdispersion is high, a phenomenon already encountered with the <italic>L</italic><sup>2</sup> loss when the distribution of errors is Cauchy. However, the knowledge of the true value of <italic>&#x003d5;</italic> does not affect the run-time of the algorithm. Figure <xref ref-type="fig" rid="F4">4</xref> illustrates through the Rand Index the quality of the proposed segmentation for a few values of <italic>n</italic>. Even though the indexes are slightly lower for <italic>&#x003d5;</italic><sub>1</sub> than for <italic>&#x003d5;</italic><sub>2</sub> (see left panel), they range between 0.94 and 1 showing a great quality in the results. Moreover, the knowledge of <italic>&#x003d5;</italic> does not increase the quality (see right panel), which validates the use of our estimator. We can therefore conclude that the run-time of our algorithm without compression is roughly 40&#x000d7;<italic>K</italic><sub><italic>m</italic><italic>a</italic><italic>x</italic></sub>&#x000d7;<italic>n</italic>/10<sup>6</sup>s.</p><fig id="F3" position="float"><label>Figure 3</label><caption><p><bold>Run-time analysis for segmentation with negative binomial distribution.</bold> This figure displays the normalized (by <italic>K</italic><sub>max</sub>) run-time in seconds of the <bold>Segmentor3IsBack</bold> package for the segmentation of signals with increasing length <italic>n</italic>, for two values of the dispersion <italic>&#x003d5;</italic>, and with separate analyses for a known value or an estimated value. While the algorithm is faster for more over-dispersed data, the estimation of the parameter does not slow the processing.</p></caption><graphic xlink:href="1748-7188-9-6-3"/></fig><fig id="F4" position="float"><label>Figure 4</label><caption><p><bold>Rand Index for the quality of the segmentation.</bold> This figure displays the boxplot of the Rand Index computed for each of the hundred simulations performed in the following situations: comparing the values with <italic>&#x003d5;</italic><sub>1</sub> and <italic>&#x003d5;</italic><sub>2</sub> when estimated (left figure), and comparing the impact of estimating <italic>&#x003d5;</italic><sub>1</sub> (right figure). While the estimation does not decrease the quality of the segmentation, the value of the dispersion affects the recovery of the true change-points.</p></caption><graphic xlink:href="1748-7188-9-6-4"/></fig></sec><sec><title>Yeast RNAseq experiment</title><p>We applied our algorithm to the segmentation of chromosome 1 of the <italic>S. Cerevisiae</italic> (yeast) using RNA-Seq data from the Sherlock Laboratory at Stanford University [<xref ref-type="bibr" rid="B20">20</xref>], publicly available from the NCBI&#x02019;s Sequence Read Archive (SRA, <ext-link ext-link-type="uri" xlink:href="http://www.ncbi.nlm.nih.gov/sra">http://www.ncbi.nlm.nih.gov/sra</ext-link>, accession number SRA048710). We selected the number of segments using our oracle penalty described in the previous section. An existing annotation of translated regions (<italic>i.e.</italic> excluding un-translated regions (UTR)) is available on the Saccharomyces Genome Database (SGD) at <ext-link ext-link-type="uri" xlink:href="http://www.yeastgenome.org">http://www.yeastgenome.org</ext-link>, which allows us to validate our results.</p><p>With a run-time of 27 minutes without compression, and 5.4 minutes with compression (for a signal length of 230218), we selected 125 segments with the negative binomial distribution. Most of those segments (all but 3) can be related to the official annotation, however as expected segments corresponding to transcribed regions (as opposed to intergenic regions) were found to surround known genes from the SGD due to the difference between transcribed and translated regions. Figure <xref ref-type="fig" rid="F1">1</xref> illustrates the result.</p><p>We compared our segmentation with that corresponding to the SGD annotation through the Hellinger distance by fitting a negative binomial distribution on each segment and repeated this comparison with the other two algorithms able to process long count datasets: PELT [<xref ref-type="bibr" rid="B16">16</xref>] and Binary Segmentation [<xref ref-type="bibr" rid="B6">6</xref>], both implemented in the R package <monospace>changepoint</monospace> for the Poisson distribution. For fair comparison, we also used the PDP algorithm for the Poisson loss. Figure <xref ref-type="fig" rid="F5">5</xref>, together with Table <xref ref-type="table" rid="T1">1</xref> which gives the estimated number of segments, the overall Hellinger score <inline-formula><mml:math id="M67" name="1748-7188-9-6-i70" overflow="scroll"><mml:mfenced open="(" close=")"><mml:mrow><mml:munder><mml:mrow><mml:mo mathsize="big">&#x02211;</mml:mo></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>/</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math></inline-formula> and the number of change-points falling within annotated translated regions, illustrates the result and shows that we outperform the other approaches. Moreover, most of the Hellinger peaks observed can be explained by the fact that we are comparing the annotation of transcribed regions with that of translated regions.</p><fig id="F5" position="float"><label>Figure 5</label><caption><p><bold>Comparison of proposed segmentation with annotation and PELT and Binary Segmentation algorithms.</bold> Each figure gives the Hellinger distance between the estimated segmentation of the algorithm (top: PDP with negative binomial, then: PDP with Poisson, third: PELT, and bottom: Binary segmentation) and that of the SGD. The PDP algorithm with the negative binomial distribution seems to outperform other algorithms.</p></caption><graphic xlink:href="1748-7188-9-6-5"/></fig><table-wrap position="float" id="T1"><label>Table 1</label><caption><p>Comparison of algorithm performance on real data</p></caption><table frame="hsides" rules="groups" border="1"><colgroup><col align="left"/><col align="center"/><col align="center"/><col align="center"/></colgroup><thead valign="top"><tr><th align="left" valign="bottom"><bold>Algorithm</bold><hr/></th><th align="center" valign="bottom"><bold>Number of</bold><hr/></th><th align="center" valign="bottom"><bold>Hellinger</bold><hr/></th><th align="center" valign="bottom"><bold>False</bold><hr/></th></tr><tr><th align="left">&#x000a0;</th><th align="center"><bold>segments</bold></th><th align="center"><bold>score</bold></th><th align="center"><bold>positives</bold></th></tr></thead><tbody valign="top"><tr><td align="left" valign="bottom">PDPA- negative binomial<hr/></td><td align="center" valign="bottom">125<hr/></td><td align="center" valign="bottom">0.0120<hr/></td><td align="center" valign="bottom">39<hr/></td></tr><tr><td align="left" valign="bottom">PDPA- Poisson<hr/></td><td align="center" valign="bottom">106<hr/></td><td align="center" valign="bottom">0.0187<hr/></td><td align="center" valign="bottom">77<hr/></td></tr><tr><td align="left" valign="bottom">PELT<hr/></td><td align="center" valign="bottom">3416<hr/></td><td align="center" valign="bottom">0.0188<hr/></td><td align="center" valign="bottom">3003<hr/></td></tr><tr><td align="left">Binary Segmentation</td><td align="center">2408</td><td align="center">0.0151</td><td align="center">2072</td></tr></tbody></table><table-wrap-foot><p>Overall Hellinger score of each of the segmentation algorithms, and number of estimated change-points falling within regions annotated as translated (thus considered as false positives).</p></table-wrap-foot></table-wrap></sec><sec><title>Analysis of complex organisms</title><p>The issues raised in the analysis of RNA-Seq and DNA-Seq data differ. In the first case, the number of segments that we hope to select is roughly twice the number of expressed exons, therefore the order of <italic>K</italic><sub><italic>m</italic><italic>a</italic><italic>x</italic></sub> varies from 10<sup>2</sup> (small chromosomes from lower organisms, e.g. yeast) to 10<sup>4</sup> (large chromosomes from higher organisms, e.g. human). However, when aligned to a reference genome, RNA-Seq data is expected to present large plateaux of zeros at non-coding regions (for instance, 98% of the human genome) and at non expressed regions. The compression option of our algorithm then allows us to reduce the size of the profile by a factor of 10 to 10<sup>3</sup>. Moreover, it is well-known that centromere regions are large non-coding regions where no change-point is expected, and we therefore propose to divide the profile into two parts at such regions. As a proof of concept we ran our algorithm with compression on an RNA-seq profile of the small arm of the 4th chromosome of <italic>Arabidopsis Thaliana</italic> (<italic>n</italic>=4.10<sup>6</sup>, <italic>K</italic><sub><italic>m</italic><italic>a</italic><italic>x</italic></sub>=6.10<sup>3</sup>) and selected 4289 segments after a compression factor of 10 and a run-time of 19 hours on a 2.4Ghz computer. The data was kindly provided by some of our collaborators.</p><p>DNA-Seq data on the other hand will present much smaller plateaux. While this implies that the compression will be less efficient, the profile can still be summarized into a dataset the length of which will be smaller than the total amount of mapped reads.Most importantly, in these experiments the expected number of segments is drastically smaller as the number of chromosomic aberrations is generally limited to less than one hundred per chromosome, even in pathologies such as cancer.</p></sec></sec><sec sec-type="conclusions"><title>Conclusion</title><p>Segmentation has been a useful tool for the analysis of biological datasets for a few decades. We propose to extend its application with the use of the Pruned Dynamic Programming algorithm for count datasets such as outputs of sequencing experiments. We show that the negative binomial distribution can be used to model such datasets on the condition that the overdispersion parameter is known and have proposed an estimator of this parameter that performs well in our segmentation framework.</p><p>We propose to choose the number of segments using our oracle penalty criterion, which makes the package fully operational. This package also allows the use of other criteria such as AIC or BIC. Similarly, the algorithm is not restricted to the negative binomial distribution but also allows the use of Poisson and Gaussian losses for instance and could easily be adapted to other convex one-parameter losses.</p><p>With its empirical complexity of <inline-formula><mml:math id="M68" name="1748-7188-9-6-i71" overflow="scroll"><mml:mi mathvariant="script">O</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mo>max</mml:mo></mml:mrow></mml:msub><mml:mi>n</mml:mi><mml:mo>log</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math></inline-formula>, it can be applied to large signals such as read-alignment of whole chromosomes, and we illustrated its result on a real dataset from the yeast genomes. Moreover, this algorithm can be used as a base for further analysis. For example, [<xref ref-type="bibr" rid="B28">28</xref>] use it to initialize their Hidden Markov Model to compute change-point location probabilities.</p></sec><sec><title>Availability and requirements</title><p>&#x02022; Project name: Segmentor3IsBack</p><p>&#x02022; Project home page: <ext-link ext-link-type="uri" xlink:href="http://cran.r-project.org/web/packages/Segmentor3IsBack/index.html">http://cran.r-project.org/web/packages/Segmentor3IsBack/index.html</ext-link></p><p>&#x02022; Operating systems: Platform independent</p><p>&#x02022; Programming language: C++ code embedded in <italic>R</italic> package</p><p>&#x02022; License: GNU GPL</p><p>&#x02022; Any restrictions to use by non-academics: none</p></sec><sec><title>Appendix</title><fig id="a1" position="float"><label>Algorithm 1 The PDP algorithm</label><graphic xlink:href="1748-7188-9-6-i72"/></fig><sec><title>Proof of Proposition 0.3</title><sec><title/><sec><title/><p><bold>Searching for one change-point</bold>&#x02009;Let us first consider a segmentation in 2 segments with a breakpoint at <italic>t</italic>. We define <italic>P</italic><sub><italic>t</italic></sub>(<italic>&#x003b8;</italic><sub>1</sub>,<italic>&#x003b8;</italic><sub>2</sub>), the cost of this segmentation given some parameter <italic>&#x003b8;</italic><sub>1</sub> for the first segment and <italic>&#x003b8;</italic><sub>2</sub> for the second segment: </p><p><disp-formula><mml:math id="M69" name="1748-7188-9-6-i73" overflow="scroll"><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mfenced open="(" close=")"><mml:msub><mml:mrow><mml:mi>&#x003b8;</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>&#x003b8;</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mfenced><mml:mo>=</mml:mo><mml:munderover accentunder="true"><mml:mrow><mml:mi mathsize="big">&#x02211;</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:munderover><mml:mi>&#x003b3;</mml:mi><mml:mspace width="0.1em"/><mml:mfenced open="(" close=")"><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>&#x003b8;</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mfenced><mml:mspace width="0.5em"/><mml:mo>+</mml:mo><mml:mspace width="0.5em"/><mml:munderover accentunder="true"><mml:mrow><mml:mi mathsize="big">&#x02211;</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:munderover><mml:mi>&#x003b3;</mml:mi><mml:mspace width="0.1em"/><mml:mfenced open="(" close=")"><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>&#x003b8;</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mfenced><mml:mi>.</mml:mi></mml:math></disp-formula></p><p>The optimal cost <italic>P</italic><sub><italic>t</italic></sub> is: </p><p><disp-formula><mml:math id="M70" name="1748-7188-9-6-i74" overflow="scroll"><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mtext mathvariant="italic">min</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>&#x003b8;</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mfenced open="{" close="}"><mml:mrow><mml:munderover accentunder="true"><mml:mrow><mml:mi mathsize="big">&#x02211;</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:munderover><mml:mi>&#x003b3;</mml:mi><mml:mspace width="0.1em"/><mml:mfenced open="(" close=")"><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>&#x003b8;</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mfenced></mml:mrow></mml:mfenced><mml:mspace width="0.5em"/><mml:mo>+</mml:mo><mml:mspace width="0.5em"/><mml:msub><mml:mrow><mml:mtext mathvariant="italic">min</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>&#x003b8;</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mfenced open="{" close="}"><mml:mrow><mml:munderover accentunder="true"><mml:mrow><mml:mi mathsize="big">&#x02211;</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:munderover><mml:mi>&#x003b3;</mml:mi><mml:mspace width="0.1em"/><mml:mfenced open="(" close=")"><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>&#x003b8;</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mfenced></mml:mrow></mml:mfenced><mml:mi>.</mml:mi></mml:math></disp-formula></p><p>Having these notations, let us prove the following lemma:</p><sec><title><bold>Lemma 0.4.</bold></title><p>&#x02022; If <italic>t</italic><sub>1</sub>=1 and <italic>t</italic><sub>2</sub>=<italic>n</italic> then &#x02200; <italic>t</italic><italic>P</italic><sub><italic>t</italic></sub>&#x02265;<italic>C</italic><sub>1,<italic>n</italic></sub></p><p>&#x02022; If <italic>t</italic><sub>1</sub>=1 and <italic>t</italic><sub>2</sub>&#x0003c;<italic>n</italic> then &#x02200; <italic>t</italic><sub>1</sub>-1&#x02264;<italic>t</italic>&#x02264;<italic>t</italic><sub>2</sub> we have <inline-formula><mml:math id="M71" name="1748-7188-9-6-i75" overflow="scroll"><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>&#x02265;</mml:mo><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub></mml:math></inline-formula></p><p>&#x02022; If <italic>t</italic><sub>1</sub>&#x0003e;1 and <italic>t</italic><sub>2</sub>=<italic>n</italic> then &#x02200; <italic>t</italic><sub>1</sub>-1&#x02264;<italic>t</italic>&#x02264;<italic>t</italic><sub>2</sub> we have <inline-formula><mml:math id="M72" name="1748-7188-9-6-i76" overflow="scroll"><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>&#x02265;</mml:mo><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></inline-formula></p><p>&#x02022; If <italic>t</italic><sub>1</sub>&#x0003e;1 and <italic>t</italic><sub>2</sub>&#x0003c;<italic>n</italic> then &#x02200; <italic>t</italic><sub>1</sub>-1&#x02264;<italic>t</italic>&#x02264;<italic>t</italic><sub>2</sub> we have <inline-formula><mml:math id="M73" name="1748-7188-9-6-i77" overflow="scroll"><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>&#x02265;</mml:mo><mml:mtext mathvariant="italic">min</mml:mtext><mml:mfenced open="{" close="}"><mml:mrow><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:math></inline-formula></p><p>Proof</p></sec></sec></sec><sec><title/><sec><title>First scenario [ <italic>t</italic><sub>1</sub>=1 and <italic>t</italic><sub>2</sub>=<italic>n</italic>]</title><p>We have: </p><p><disp-formula><mml:math id="M74" name="1748-7188-9-6-i78" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>t.</mml:mi><mml:msub><mml:mrow><mml:mtext mathvariant="italic">min</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>&#x003b8;</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mfenced open="{" close="}"><mml:mrow><mml:mi>&#x003b3;</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>&#x003b8;</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo><mml:mi>.</mml:mi><mml:msub><mml:mrow><mml:mtext mathvariant="italic">min</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>&#x003b8;</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mfenced open="{" close="}"><mml:mrow><mml:mi>&#x003b3;</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>&#x003b8;</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mi>.</mml:mi></mml:mrow></mml:math></disp-formula></p><p>Thus we get: <italic>P</italic><sub><italic>t</italic></sub>&#x02265;<italic>C</italic><sub>1,<italic>n</italic></sub>.</p></sec></sec><sec><title/><sec><title>Second scenario [ <italic>t</italic><sub>1</sub>=1 and <italic>t</italic><sub>2</sub>&#x0003c;<italic>n</italic>]</title><p>For any <italic>t</italic> such that <italic>t</italic>&#x02264;<italic>t</italic><sub>2</sub> we have: </p><p><disp-formula><mml:math id="M75" name="1748-7188-9-6-i79" overflow="scroll"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mspace width="2.77626pt"/><mml:mi>t.</mml:mi><mml:msub><mml:mrow><mml:mtext mathvariant="italic">min</mml:mtext></mml:mrow><mml:mrow><mml:mi>&#x003b8;</mml:mi></mml:mrow></mml:msub><mml:mfenced open="{" close="}"><mml:mrow><mml:mi>&#x003b3;</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>&#x003b8;</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mfenced></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mspace width="3em"/><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mtext mathvariant="italic">min</mml:mtext></mml:mrow><mml:mrow><mml:mi>&#x003b8;</mml:mi></mml:mrow></mml:msub><mml:mfenced open="{" close="}"><mml:mrow><mml:mfenced open="(" close=")"><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>-</mml:mo><mml:mi>t</mml:mi></mml:mfenced><mml:mi>&#x003b3;</mml:mi><mml:mfenced open="(" close=")"><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>&#x003b8;</mml:mi></mml:mfenced><mml:mo>+</mml:mo><mml:munderover accentunder="true"><mml:mrow><mml:mi mathsize="big">&#x02211;</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:munderover><mml:mi>&#x003b3;</mml:mi><mml:mfenced open="(" close=")"><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>&#x003b8;</mml:mi></mml:mfenced></mml:mrow></mml:mfenced><mml:mi>.</mml:mi></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula></p><p>Thus we have: </p><p><disp-formula><mml:math id="M76" name="1748-7188-9-6-i80" overflow="scroll"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mspace width="2.77626pt"/><mml:mo>&#x02265;</mml:mo><mml:mspace width="2.77626pt"/><mml:mi>t.</mml:mi><mml:msub><mml:mrow><mml:mtext mathvariant="italic">min</mml:mtext></mml:mrow><mml:mrow><mml:mi>&#x003b8;</mml:mi></mml:mrow></mml:msub><mml:mfenced open="{" close="}"><mml:mrow><mml:mi>&#x003b3;</mml:mi><mml:mfenced open="(" close=")"><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>&#x003b8;</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mfenced></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mfenced open="(" close=")"><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>-</mml:mo><mml:mi>t</mml:mi></mml:mfenced><mml:mi>.</mml:mi><mml:msub><mml:mrow><mml:mtext mathvariant="italic">min</mml:mtext></mml:mrow><mml:mrow><mml:mi>&#x003b8;</mml:mi></mml:mrow></mml:msub><mml:mfenced open="{" close="}"><mml:mrow><mml:mi>&#x003b3;</mml:mi><mml:mfenced open="(" close=")"><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>&#x003b8;</mml:mi></mml:mfenced></mml:mrow></mml:mfenced></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mspace width="3em"/><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mtext mathvariant="italic">min</mml:mtext></mml:mrow><mml:mrow><mml:mi>&#x003b8;</mml:mi></mml:mrow></mml:msub><mml:mfenced open="{" close="}"><mml:mrow><mml:munderover accentunder="true"><mml:mrow><mml:mi mathsize="big">&#x02211;</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:munderover><mml:mi>&#x003b3;</mml:mi><mml:mfenced open="(" close=")"><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>&#x003b8;</mml:mi></mml:mfenced></mml:mrow></mml:mfenced><mml:mi>.</mml:mi></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula></p><p>And we get <inline-formula><mml:math id="M77" name="1748-7188-9-6-i81" overflow="scroll"><mml:mo>&#x02200;</mml:mo><mml:mspace width="1em"/><mml:mi>t</mml:mi><mml:mo>&#x02264;</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mspace width="1em"/><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>&#x02265;</mml:mo><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub></mml:math></inline-formula>.</p></sec></sec><sec><title/><sec><title>Third scenario [ <italic>t</italic><sub>1</sub>&#x0003e;1 and <italic>t</italic><sub>2</sub>=<italic>n</italic>]</title><p>We get <inline-formula><mml:math id="M78" name="1748-7188-9-6-i82" overflow="scroll"><mml:mo>&#x02200;</mml:mo><mml:mspace width="1em"/><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>&#x02264;</mml:mo><mml:mi>t</mml:mi><mml:mspace width="1em"/><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>&#x02265;</mml:mo><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></inline-formula> by reversing the index and using scenario 2.</p></sec></sec><sec><title/><sec><title>Fourth scenario [ <italic>t</italic><sub>1</sub>&#x0003e;1 and <italic>t</italic><sub>2</sub>&#x0003c;<italic>n</italic>]</title><p>For any <italic>t</italic> such that <italic>t</italic><sub>1</sub>-1&#x02264;<italic>t</italic>&#x02264;<italic>t</italic><sub>2</sub> we obtain: </p><p><disp-formula><mml:math id="M79" name="1748-7188-9-6-i83" overflow="scroll"><mml:mtable class="eqnarray" columnalign="left"><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mfenced open="(" close=")"><mml:msub><mml:mrow><mml:mi>&#x003b8;</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>&#x003b8;</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mfenced><mml:mo>=</mml:mo><mml:munderover accentunder="true"><mml:mrow><mml:mi mathsize="big">&#x02211;</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:mi>&#x003b3;</mml:mi><mml:mfenced open="(" close=")"><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>&#x003b8;</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mfenced><mml:mspace width="1em"/><mml:mo>+</mml:mo><mml:munderover accentunder="true"><mml:mrow><mml:mi mathsize="big">&#x02211;</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:munderover><mml:mi>&#x003b3;</mml:mi><mml:mfenced open="(" close=")"><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>&#x003b8;</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mfenced></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mspace width="6em"/><mml:mo>+</mml:mo><mml:mspace width="0.5em"/><mml:mfenced open="(" close=")"><mml:mi>t</mml:mi><mml:mo>-</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mfenced><mml:mi>&#x003b3;</mml:mi><mml:mfenced open="(" close=")"><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>&#x003b8;</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mfenced><mml:mo>+</mml:mo><mml:mspace width="0.5em"/><mml:mfenced open="(" close=")"><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>-</mml:mo><mml:mi>t</mml:mi></mml:mfenced><mml:mi>&#x003b3;</mml:mi><mml:mfenced open="(" close=")"><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>&#x003b8;</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mfenced><mml:mi>.</mml:mi></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula></p><p>Thus, for fixed <italic>&#x003b8;</italic><sub>1</sub> and <italic>&#x003b8;</italic><sub>2</sub> and for <italic>t</italic> &#x02208; [ <italic>t</italic><sub>1</sub>-1,<italic>t</italic><sub>2</sub>], <italic>P</italic><sub><italic>t</italic></sub>(<italic>&#x003b8;</italic><sub>1</sub>,<italic>&#x003b8;</italic><sub>2</sub>) is a linear function of <italic>t</italic>. Thus we obtain that for any <italic>&#x003b8;</italic><sub>1</sub> and <italic>&#x003b8;</italic><sub>2</sub>: </p><p><disp-formula><mml:math id="M80" name="1748-7188-9-6-i84" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>&#x003b8;</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>&#x003b8;</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>&#x02265;</mml:mo><mml:mtext mathvariant="italic">min</mml:mtext><mml:mfenced open="{" close="}"><mml:mrow><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>&#x003b8;</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>&#x003b8;</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>&#x003b8;</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>&#x003b8;</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:mfenced><mml:mo>&#x02265;</mml:mo><mml:mtext mathvariant="italic">min</mml:mtext><mml:mfenced open="{" close="}"><mml:mrow><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mi>.</mml:mi></mml:mrow></mml:math></disp-formula> As this is true for any <italic>&#x003b8;</italic><sub>1</sub> and <italic>&#x003b8;</italic><sub>2</sub> we get <inline-formula><mml:math id="M81" name="1748-7188-9-6-i85" overflow="scroll"><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>&#x02265;</mml:mo><mml:mtext mathvariant="italic">min</mml:mtext><mml:mfenced open="{" close="}"><mml:mrow><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:math></inline-formula> &#x025a0;</p></sec></sec><sec><title/><sec><title>Proof of the main proposition</title><p>Assume that we have a segmentation <italic>m</italic> in <inline-formula><mml:math id="M82" name="1748-7188-9-6-i86" overflow="scroll"><mml:msub><mml:mrow><mml:mi mathvariant="script">&#x02133;</mml:mi></mml:mrow><mml:mrow><mml:mi>K</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> with a breakpoint <italic>&#x003c4;</italic><sub><italic>k</italic></sub> in a plateau. Then applying lemma 0.4 on the sequence <inline-formula><mml:math id="M83" name="1748-7188-9-6-i87" overflow="scroll"><mml:msub><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>&#x02208;</mml:mo><mml:mfenced open="{" close="}"><mml:mrow><mml:msub><mml:mrow><mml:mi>&#x003c4;</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>&#x02026;</mml:mo><mml:msub><mml:mrow><mml:mi>&#x003c4;</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:mrow></mml:msub></mml:math></inline-formula> we see that <italic>&#x003c4;</italic><sub><italic>k</italic></sub> can either be discarded or moved to <italic>t</italic><sub>1</sub>-1 or <italic>t</italic><sub>2</sub> without increasing the cost. Thus there exists a segmentation in <italic>K</italic> or fewer segments without any change-point in the plateau such that its optimal cost is <italic>C</italic><sub><italic>K</italic>,<italic>n</italic></sub>. &#x025a0;</p><p>This theorem is more subtle than we might have thought based on our intuition. It does not mean that a change-point in a plateau is never optimal but only that it is not necessary to have change-points in plateaux to achieve optimality.</p></sec></sec></sec></sec><sec><title>Abbreviations</title><p>PELT: Pruned exact linear time; PDP: Pruned dynamic programming; AIC: Akaike information criterion; BIC: Bayesian information criterion; NCBI: National Center for Biotechnology Information; SGD: Saccharomyces genome database.</p></sec><sec><title>Competing interests</title><p>The authors have no competing interest to declare.</p></sec><sec><title>Authors&#x02019; contributions</title><p>AC co-wrote the C++ code, wrote the R-package, performed data analysis and co-wrote the manuscript. MK co-wrote the C++ code. EL co-supervised the work and co-wrote the manuscript. GR co-wrote the C++ code, and co-wrote the manuscript. SR co-wrote the manuscript and co-supervised the work. All authors read and approved the final manuscript.</p></sec></body><back><sec><title>Acknowledgements</title><p>We thank V&#x000e9;ronique Brunaud for providing the RNA-seq profile of <italic>Arabidopsis Thaliana</italic>. We also thank our anonymous referee for helpful comments on the presentation of the algorithm.</p></sec><ref-list><ref id="B1"><mixed-citation publication-type="journal"><name><surname>Braun</surname><given-names>JV</given-names></name><name><surname>Muller</surname><given-names>HG</given-names></name><article-title><bold>Statistical methods for DNA sequence segmentation</bold></article-title><source>Stat Sci</source><year>1998</year><volume>13</volume><issue>2</issue><fpage>142</fpage><lpage>162</lpage></mixed-citation></ref><ref id="B2"><mixed-citation publication-type="journal"><name><surname>Durot</surname><given-names>C</given-names></name><name><surname>Lebarbier</surname><given-names>E</given-names></name><name><surname>Tocquet</surname><given-names>AS</given-names></name><article-title><bold>Estimating the joint distribution of independent categorical variables via model selection</bold></article-title><source>Bernoulli</source><year>2009</year><volume>15</volume><fpage>475</fpage><lpage>507</lpage><pub-id pub-id-type="doi">10.3150/08-BEJ155</pub-id></mixed-citation></ref><ref id="B3"><mixed-citation publication-type="book"><name><surname>Bockhorst</surname><given-names>J</given-names></name><name><surname>Jojic</surname><given-names>N</given-names></name><article-title><bold>Discovering patterns in biological sequences by optimal segmentation</bold></article-title><source>Proceedings of the 23rd Conference in Uncertainty in Artificial Intelligence</source><year>2007</year><publisher-name>AUAI Press</publisher-name></mixed-citation></ref><ref id="B4"><mixed-citation publication-type="journal"><name><surname>Zhang</surname><given-names>Z</given-names></name><name><surname>Lange</surname><given-names>K</given-names></name><name><surname>Sabatti</surname><given-names>C</given-names></name><article-title><bold>Reconstructing DNA copy number by joint segmentation of multiple sequences</bold></article-title><source>BMC Bioinformatics</source><year>2012</year><volume>13</volume><fpage>205</fpage><pub-id pub-id-type="doi">10.1186/1471-2105-13-205</pub-id><?supplied-pmid 22897923?><pub-id pub-id-type="pmid">22897923</pub-id></mixed-citation></ref><ref id="B5"><mixed-citation publication-type="journal"><name><surname>Erdman</surname><given-names>C</given-names></name><name><surname>Emerson</surname><given-names>JW</given-names></name><article-title><bold>A fast Bayesian change point analysis for the segmentation of microarray data</bold></article-title><source>Bioinformatics</source><year>2008</year><volume>24</volume><issue>19</issue><fpage>2143</fpage><lpage>2148</lpage><pub-id pub-id-type="doi">10.1093/bioinformatics/btn404</pub-id><?supplied-pmid 18667443?><pub-id pub-id-type="pmid">18667443</pub-id></mixed-citation></ref><ref id="B6"><mixed-citation publication-type="journal"><name><surname>Olshen</surname><given-names>AB</given-names></name><name><surname>Venkatraman</surname><given-names>ES</given-names></name><name><surname>Lucito</surname><given-names>R</given-names></name><name><surname>Wigler</surname><given-names>M</given-names></name><article-title><bold>Circular binary segmentation for the analysis of array-based DNA copy number data</bold></article-title><source>Biostat (Oxford, England)</source><year>2004</year><volume>5</volume><issue>4</issue><fpage>557</fpage><lpage>572</lpage><pub-id pub-id-type="doi">10.1093/biostatistics/kxh008</pub-id></mixed-citation></ref><ref id="B7"><mixed-citation publication-type="journal"><name><surname>Picard</surname><given-names>F</given-names></name><name><surname>Robin</surname><given-names>S</given-names></name><name><surname>Lavielle</surname><given-names>M</given-names></name><name><surname>Vaisse</surname><given-names>C</given-names></name><name><surname>Daudin</surname><given-names>J</given-names></name><article-title><bold>A statistical approach for array CGH data analysis</bold></article-title><source>BMC Bioinformatics</source><year>2005</year><volume>6</volume><fpage>27</fpage><pub-id pub-id-type="doi">10.1186/1471-2105-6-27</pub-id><?supplied-pmid 15705208?><pub-id pub-id-type="pmid">15705208</pub-id></mixed-citation></ref><ref id="B8"><mixed-citation publication-type="journal"><name><surname>Picard</surname><given-names>F</given-names></name><name><surname>Lebarbier</surname><given-names>E</given-names></name><name><surname>Hoebeke</surname><given-names>M</given-names></name><name><surname>Rigaill</surname><given-names>G</given-names></name><name><surname>Thiam</surname><given-names>B</given-names></name><name><surname>Robin</surname><given-names>S</given-names></name><article-title><bold>Joint segmentation, calling and normalization of multiple CGH profiles</bold></article-title><source>Biostatistics</source><year>2011</year><volume>12</volume><issue>3</issue><fpage>413</fpage><lpage>428</lpage><pub-id pub-id-type="doi">10.1093/biostatistics/kxq076</pub-id><?supplied-pmid 21209153?><pub-id pub-id-type="pmid">21209153</pub-id></mixed-citation></ref><ref id="B9"><mixed-citation publication-type="journal"><name><surname>Chiang</surname><given-names>DY</given-names></name><name><surname>Getz</surname><given-names>G</given-names></name><name><surname>Jaffe</surname><given-names>DB</given-names></name><name><surname>O&#x02019;Kelly</surname><given-names>MJ</given-names></name><name><surname>Zhao</surname><given-names>X</given-names></name><name><surname>Carter</surname><given-names>SL</given-names></name><name><surname>Russ</surname><given-names>C</given-names></name><name><surname>Nusbaum</surname><given-names>C</given-names></name><name><surname>Meyerson</surname><given-names>M</given-names></name><name><surname>Lander</surname><given-names>ES</given-names></name><article-title><bold>High-resolution mapping of copy-number alterations with massively parallel sequencing</bold></article-title><source>Nat Methods</source><year>2009</year><volume>6</volume><fpage>99</fpage><lpage>103</lpage><pub-id pub-id-type="doi">10.1038/nmeth.1276</pub-id><?supplied-pmid 19043412?><pub-id pub-id-type="pmid">19043412</pub-id></mixed-citation></ref><ref id="B10"><mixed-citation publication-type="journal"><name><surname>Xie</surname><given-names>C</given-names></name><name><surname>Tammi</surname><given-names>MT</given-names></name><article-title><bold>CNV-seq, a new method to detect copy number variation using high-throughput sequencing</bold></article-title><source>BMC Bioinformatics</source><year>2009</year><volume>10</volume><fpage>80</fpage><pub-id pub-id-type="doi">10.1186/1471-2105-10-80</pub-id><?supplied-pmid 19267900?><pub-id pub-id-type="pmid">19267900</pub-id></mixed-citation></ref><ref id="B11"><mixed-citation publication-type="journal"><name><surname>Yoon</surname><given-names>S</given-names></name><name><surname>Xuan</surname><given-names>Z</given-names></name><name><surname>Makarov</surname><given-names>V</given-names></name><name><surname>Ye</surname><given-names>K</given-names></name><name><surname>Sebat</surname><given-names>J</given-names></name><article-title><bold>Sensitive and accurate detection of copy number variants using read depth of coverage</bold></article-title><source>Genome Res</source><year>2009</year><volume>19</volume><fpage>1586</fpage><lpage>1592</lpage><pub-id pub-id-type="doi">10.1101/gr.092981.109</pub-id><?supplied-pmid 19657104?><pub-id pub-id-type="pmid">19657104</pub-id></mixed-citation></ref><ref id="B12"><mixed-citation publication-type="journal"><name><surname>Boeva</surname><given-names>V</given-names></name><name><surname>Zinovyev</surname><given-names>A</given-names></name><name><surname>Bleakley</surname><given-names>K</given-names></name><name><surname>Vert</surname><given-names>JP</given-names></name><name><surname>Janoueix-Lerosey</surname><given-names>I</given-names></name><name><surname>Delattre</surname><given-names>O</given-names></name><name><surname>Barillot</surname><given-names>E</given-names></name><article-title><bold>Control-free calling of copy number alterations in deep-sequencing data using GC-content normalization</bold></article-title><source>Bioinformatics (Oxford, England)</source><year>2011</year><volume>27</volume><fpage>268</fpage><lpage>9</lpage><pub-id pub-id-type="doi">10.1093/bioinformatics/btq635</pub-id></mixed-citation></ref><ref id="B13"><mixed-citation publication-type="journal"><name><surname>Shen</surname><given-names>JJ</given-names></name><name><surname>Zhang</surname><given-names>NR</given-names></name><article-title><bold>Change-point model on nonhomogeneous Poisson processes with application in copy number profiling by next-generation DNA sequencing</bold></article-title><source>Ann Appl Stat</source><year>2012</year><volume>6</volume><issue>2</issue><fpage>476</fpage><lpage>496</lpage><pub-id pub-id-type="doi">10.1214/11-AOAS517</pub-id></mixed-citation></ref><ref id="B14"><mixed-citation publication-type="journal"><name><surname>Rivera</surname><given-names>C</given-names></name><name><surname>Walther</surname><given-names>G</given-names></name><article-title><bold>Optimal detection of a jump in the intensity of a Poisson process or in a density with likelihood ratio statistics</bold></article-title><source>Scand J Stat</source><year>2013</year><volume>40</volume><issue>4</issue><fpage>752</fpage><lpage>769</lpage><pub-id pub-id-type="doi">10.1111/sjos.12027</pub-id></mixed-citation></ref><ref id="B15"><mixed-citation publication-type="journal"><name><surname>Franke</surname><given-names>J</given-names></name><name><surname>Kirch</surname><given-names>C</given-names></name><name><surname>Kamgaing</surname><given-names>JT</given-names></name><article-title><bold>Changepoints in times series of counts</bold></article-title><source>J Time Series Anal</source><year>2012</year><volume>33</volume><issue>5</issue><fpage>757</fpage><lpage>770</lpage><pub-id pub-id-type="doi">10.1111/j.1467-9892.2011.00778.x</pub-id></mixed-citation></ref><ref id="B16"><mixed-citation publication-type="journal"><name><surname>Killick</surname><given-names>R</given-names></name><name><surname>Fearnhead</surname><given-names>P</given-names></name><name><surname>Eckley</surname><given-names>I</given-names></name><article-title><bold>Optimal detection of changepoints with a linear computational cost</bold></article-title><source>J Am Stat Assoc</source><year>2012</year><volume>107</volume><issue>500</issue><fpage>1590</fpage><lpage>1598</lpage><pub-id pub-id-type="doi">10.1080/01621459.2012.737745</pub-id></mixed-citation></ref><ref id="B17"><mixed-citation publication-type="journal"><name><surname>Hocking</surname><given-names>TD</given-names></name><name><surname>Schleiermacher</surname><given-names>G</given-names></name><name><surname>Janoueix-Lerosey</surname><given-names>I</given-names></name><name><surname>Boeva</surname><given-names>V</given-names></name><name><surname>Cappo</surname><given-names>J</given-names></name><name><surname>Delattre</surname><given-names>O</given-names></name><name><surname>Bach</surname><given-names>F</given-names></name><name><surname>Vert</surname><given-names>J-P</given-names></name><article-title><bold>Learning smoothing models of copy number profiles using breakpoint annotations</bold></article-title><source>BMC Bioinformatics</source><year>2013</year><volume>14</volume><issue>1</issue><fpage>164</fpage><pub-id pub-id-type="doi">10.1186/1471-2105-14-164</pub-id><?supplied-pmid 23697330?><pub-id pub-id-type="pmid">23697330</pub-id></mixed-citation></ref><ref id="B18"><mixed-citation publication-type="other"><name><surname>Rigaill</surname><given-names>G</given-names></name><article-title><bold>Pruned dynamic programming for optimal multiple change-point detection</bold></article-title><source>Arxiv:1004.0887</source><year>2010</year><comment>[<ext-link ext-link-type="uri" xlink:href="http://arxiv.org/abs/1004.0887">http://arxiv.org/abs/1004.0887</ext-link>]</comment></mixed-citation></ref><ref id="B19"><mixed-citation publication-type="book"><name><surname>Johnson</surname><given-names>N</given-names></name><name><surname>Kemp</surname><given-names>A</given-names></name><name><surname>Kotz</surname><given-names>S</given-names></name><source>Univariate Discrete Distributions</source><year>2005</year><publisher-name>John Wiley &#x00026; Sons Inc.</publisher-name></mixed-citation></ref><ref id="B20"><mixed-citation publication-type="journal"><name><surname>Risso</surname><given-names>D</given-names></name><name><surname>Schwartz</surname><given-names>K</given-names></name><name><surname>Sherlock</surname><given-names>G</given-names></name><name><surname>Dudoit</surname><given-names>S</given-names></name><article-title><bold>GC-Content normalization for RNA-Seq data</bold></article-title><source>BMC Bioinformatics</source><year>2011</year><volume>12</volume><fpage>480</fpage><pub-id pub-id-type="doi">10.1186/1471-2105-12-480</pub-id><?supplied-pmid 22177264?><pub-id pub-id-type="pmid">22177264</pub-id></mixed-citation></ref><ref id="B21"><mixed-citation publication-type="journal"><name><surname>Bullard</surname><given-names>J</given-names></name><name><surname>Purdom</surname><given-names>E</given-names></name><name><surname>Hansen</surname><given-names>K</given-names></name><name><surname>Dudoit</surname><given-names>S</given-names></name><article-title><bold>Evaluation of statistical methods for normalization and differential expression in mRNA-Seq experiments</bold></article-title><source>BMC Bioinformatics</source><year>2010</year><volume>11</volume><fpage>94</fpage><pub-id pub-id-type="doi">10.1186/1471-2105-11-94</pub-id><?supplied-pmid 20167110?><pub-id pub-id-type="pmid">20167110</pub-id></mixed-citation></ref><ref id="B22"><mixed-citation publication-type="journal"><name><surname>Akaike</surname><given-names>H</given-names></name><article-title><bold>A new look at the statistical model identification</bold></article-title><source>Automatic Control IEEE Trans</source><year>1974</year><volume>19</volume><issue>6</issue><fpage>716</fpage><lpage>723</lpage><pub-id pub-id-type="doi">10.1109/TAC.1974.1100705</pub-id></mixed-citation></ref><ref id="B23"><mixed-citation publication-type="journal"><name><surname>Yao</surname><given-names>Y</given-names></name><article-title><bold>Estimation of a noisy discrete-time step function: Bayes and empirical Bayes approaches</bold></article-title><source>Ann Stat</source><year>1984</year><volume>12</volume><issue>4</issue><fpage>1434</fpage><lpage>1447</lpage><pub-id pub-id-type="doi">10.1214/aos/1176346802</pub-id></mixed-citation></ref><ref id="B24"><mixed-citation publication-type="journal"><name><surname>Zhang</surname><given-names>NR</given-names></name><name><surname>Siegmund</surname><given-names>DO</given-names></name><article-title><bold>A modified Bayes information criterion with applications to the analysis of comparative genomic hybridization data</bold></article-title><source>Biometrics</source><year>2007</year><volume>63</volume><fpage>22</fpage><lpage>32</lpage><comment>[PMID: 17447926]</comment><pub-id pub-id-type="doi">10.1111/j.1541-0420.2006.00662.x</pub-id><?supplied-pmid 17447926?><pub-id pub-id-type="pmid">17447926</pub-id></mixed-citation></ref><ref id="B25"><mixed-citation publication-type="other"><name><surname>Cleynen</surname><given-names>A</given-names></name><name><surname>Lebarbier</surname><given-names>E</given-names></name><article-title><bold>Segmentation of the poisson and negative binomial rate models: a penalized estimator</bold></article-title><source>Esaim: P &#x00026; S</source><year>2014</year><comment>arXiv preprint arXiv:1301.2534</comment></mixed-citation></ref><ref id="B26"><mixed-citation publication-type="journal"><name><surname>Lebarbier</surname><given-names>E</given-names></name><article-title><bold>Detecting multiple change-points in the mean of Gaussian process by model selection</bold></article-title><source>Signal Process</source><year>2005</year><volume>85</volume><issue>4</issue><fpage>717</fpage><lpage>736</lpage><pub-id pub-id-type="doi">10.1016/j.sigpro.2004.11.012</pub-id></mixed-citation></ref><ref id="B27"><mixed-citation publication-type="journal"><name><surname>Arlot</surname><given-names>S</given-names></name><name><surname>Massart</surname><given-names>P</given-names></name><article-title><bold>Data-driven calibration of penalties for least-squares regression</bold></article-title><source>J Mach Learn Res</source><year>2009</year><volume>10</volume><fpage>245</fpage><lpage>279</lpage><comment>(electronic)</comment></mixed-citation></ref><ref id="B28"><mixed-citation publication-type="other"><name><surname>Luong</surname><given-names>TM</given-names></name><name><surname>Rozenholc</surname><given-names>Y</given-names></name><name><surname>Nuel</surname><given-names>G</given-names></name><article-title><bold>Fast estimation of posterior probabilities in change-point analysis through a constrained hidden Markov model</bold></article-title><source>Comput Stat Data Anal</source><year>2013</year></mixed-citation></ref></ref-list></back></article>
<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD v1.0 20120330//EN" "JATS-archivearticle1.dtd"> 
<article xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:mml="http://www.w3.org/1998/Math/MathML" article-type="product-review" xml:lang="en"><?DTDIdentifier.IdentifierValue article.dtd?><?DTDIdentifier.IdentifierType system?><?SourceDTD.DTDName article.dtd?><?SourceDTD.Version 1.0?><?ConverterInfo.XSLTName bmc2nlmx2.xsl?><?ConverterInfo.Version 2?><front><journal-meta><journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id><journal-id journal-id-type="iso-abbrev">BMC Bioinformatics</journal-id><journal-title-group><journal-title>BMC Bioinformatics</journal-title></journal-title-group><issn pub-type="epub">1471-2105</issn><publisher><publisher-name>BioMed Central</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="pmcid">3853020</article-id><article-id pub-id-type="publisher-id">1471-2105-14-306</article-id><article-id pub-id-type="pmid">24118878</article-id><article-id pub-id-type="doi">10.1186/1471-2105-14-306</article-id><article-categories><subj-group subj-group-type="heading"><subject>Software</subject></subj-group></article-categories><title-group><article-title>Jimena: efficient computing and system state identification for genetic regulatory networks</article-title></title-group><contrib-group><contrib contrib-type="author" id="A1"><name><surname>Karl</surname><given-names>Stefan</given-names></name><xref ref-type="aff" rid="I1">1</xref><email>stefan.karl@uni-wuerzburg.de</email></contrib><contrib contrib-type="author" corresp="yes" id="A2"><name><surname>Dandekar</surname><given-names>Thomas</given-names></name><xref ref-type="aff" rid="I1">1</xref><email>dandekar@biozentrum.uni-wuerzburg.de</email></contrib></contrib-group><aff id="I1"><label>1</label>Department of Bioinformatics, University of W&#x000fc;rzburg, Am Hubland, W&#x000fc;rzburg, Germany</aff><pub-date pub-type="collection"><year>2013</year></pub-date><pub-date pub-type="epub"><day>11</day><month>10</month><year>2013</year></pub-date><volume>14</volume><fpage>306</fpage><lpage>306</lpage><history><date date-type="received"><day>6</day><month>4</month><year>2013</year></date><date date-type="accepted"><day>3</day><month>10</month><year>2013</year></date></history><permissions><copyright-statement>Copyright &#x000a9; 2013 Karl and Dandekar; licensee BioMed Central Ltd.</copyright-statement><copyright-year>2013</copyright-year><copyright-holder>Karl and Dandekar; licensee BioMed Central Ltd.</copyright-holder><license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/2.0"><license-p>This is an open access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/2.0">http://creativecommons.org/licenses/by/2.0</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p></license></permissions><self-uri xlink:href="http://www.biomedcentral.com/1471-2105/14/306"/><abstract><sec><title>Background</title><p>Boolean networks capture switching behavior of many naturally occurring regulatory networks. For semi-quantitative modeling, interpolation between ON and OFF states is necessary. The high degree polynomial interpolation of Boolean genetic regulatory networks (GRNs) in cellular processes such as apoptosis or proliferation allows for the modeling of a wider range of node interactions than continuous activator-inhibitor models, but suffers from scaling problems for networks which contain nodes with more than ~10 inputs. Many GRNs from literature or new gene expression experiments exceed those limitations and a new approach was developed.</p></sec><sec><title>Results</title><p>(i) As a part of our new GRN simulation framework Jimena we introduce and setup Boolean-tree-based data structures; (ii) corresponding algorithms greatly expedite the calculation of the polynomial interpolation in almost all cases, thereby expanding the range of networks which can be simulated by this model in reasonable time. (iii) Stable states for discrete models are efficiently counted and identified using binary decision diagrams. As application example, we show how system states can now be sampled efficiently in small up to large scale hormone disease networks (<italic>Arabidopsis thaliana</italic> development and immunity, pathogen <italic>Pseudomonas syringae</italic> and modulation by cytokinins and plant hormones).</p></sec><sec><title>Conclusions</title><p>Jimena simulates currently available GRNs about 10-100 times faster than the previous implementation of the polynomial interpolation model and even greater gains are achieved for large scale-free networks. This speed-up also facilitates a much more thorough sampling of continuous state spaces which may lead to the identification of new stable states. Mutants of large networks can be constructed and analyzed very quickly enabling new insights into network robustness and behavior.</p></sec></abstract><kwd-group><kwd>Boolean function</kwd><kwd>Genetic regulatory network</kwd><kwd>Interpolation</kwd><kwd>Stable state</kwd><kwd>Binary decision diagram</kwd><kwd>Boolean tree</kwd></kwd-group></article-meta></front><body><sec><title>Background</title><p>For the simulation of genetic regulatory networks (GRNs) two important paradigms have been used: Discrete models, where each node has a value of either 0 or 1 and Boolean expressions are used to update the values of the nodes in each simulation step using an updating scheme like CRBN (classical random Boolean networks) or ARBN (asynchronous random Boolean networks) [<xref ref-type="bibr" rid="B1">1</xref>], and continuous models where nodes have values in the interval [0,1] and real-valued ODEs (ordinary differential equations) determine the behavior of the network.</p><p>Two commonly used continuous modeling paradigms for GRNs are activator-inhibitor-models such as the exponential standardized qualitative dynamical systems model [<xref ref-type="bibr" rid="B2">2</xref>], which is implemented in the SQUAD [<xref ref-type="bibr" rid="B3">3</xref>] simulation package, and real-valued interpolations of Boolean functions which allow for more complex node interactions.</p><p>These interpolations extend the domain and the codomain of Boolean functions {0,&#x02009;1}<sup><italic>n</italic></sup>&#x02009;&#x02192;&#x02009;{0,&#x02009;1} by defining functions [0,&#x02009;1]<sup><italic>n</italic></sup>&#x02009;&#x02192;&#x02009;[0,&#x02009;1]<sup><italic>n</italic></sup> which mimic the behavior of the original function for intermediate input values in the interval (0,1). For example, an adequate interpolation of the function <italic>B</italic>&#x02009;'&#x02009;(<italic>a</italic>,&#x02009;<italic>b</italic>)&#x02009;=&#x02009;<italic>a</italic>&#x000a0;OR&#x000a0;<italic>b</italic> for which <italic>B</italic>&#x02009;'&#x02009;(0,&#x02009;0)&#x02009;=&#x02009;0 and <italic>B</italic>&#x02009;'&#x02009;(0,&#x02009;1)&#x02009;=&#x02009;1 would be expected to return a value 0&#x02009;&#x0003c;&#x02009;&#x003be; &#x0003c;1 for the input (0,0.5).</p><p>Wittmann et al. [<xref ref-type="bibr" rid="B4">4</xref>] reviewed in detail several common interpolation strategies such as min-max fuzzy logic, product-sum fuzzy logic and piecewise linear functions (implemented for example in the BooleanNet simulation package [<xref ref-type="bibr" rid="B5">5</xref>]). We illustrate different interpolation functions in Figure&#x000a0;<xref ref-type="fig" rid="F1">1</xref>. Wittmann et al. [<xref ref-type="bibr" rid="B4">4</xref>] found that the resulting interpolations in Figure&#x000a0;<xref ref-type="fig" rid="F1">1</xref>A-C are either not smooth or do not adequately reproduce the Boolean functions they should interpolate. In response, they introduced the minimal degree polynomial BooleCube interpolation which is smooth and reproduces the Boolean function for all input vectors in {0,1}<sup><italic>n</italic></sup>.</p><fig id="F1" position="float"><label>Figure 1</label><caption><p><bold>Interpolations of the Boolean function x OR y.</bold> Different panels show <bold>A)</bold> piecewise linear functions <bold>B)</bold> product-sum fuzzy logic <bold>C)</bold> min-max fuzzy logic <bold>D)</bold> Boole-Cubes <bold>E)</bold> Hill-cubes.</p></caption><graphic xlink:href="1471-2105-14-306-1"/></fig><p>For a Boolean function <italic>B</italic>&#x02009;:&#x02009;{0,&#x02009;1}<sup><italic>n</italic></sup>&#x02009;&#x02192;&#x02009;{0,&#x02009;1}, the BooleCube interpolation <italic>C</italic>[<italic>B</italic>(<italic>x</italic><sub>1</sub>,&#x02026;,<italic>x</italic><sub><italic>n</italic></sub>)] is given by</p><p><disp-formula><mml:math id="M1" name="1471-2105-14-306-i1" overflow="scroll"><mml:mrow><mml:mtable><mml:mtr><mml:mtd columnalign="left"><mml:mi>C</mml:mi><mml:mfenced open="[" close="]"><mml:mrow><mml:mi>B</mml:mi><mml:mfenced open="(" close=")"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>&#x02026;</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:munderover><mml:mrow><mml:mo mathsize="big">&#x02211;</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>x</mml:mi><mml:mo stretchy="true">&#x000af;</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mrow><mml:mo mathsize="big">&#x02211;</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>x</mml:mi><mml:mo stretchy="true">&#x000af;</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:mrow><mml:mo>&#x02026;</mml:mo><mml:mstyle displaystyle="true"><mml:munderover><mml:mrow><mml:mo mathsize="big">&#x02211;</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>x</mml:mi><mml:mo stretchy="true">&#x000af;</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:munderover></mml:mstyle></mml:mrow></mml:mstyle></mml:mrow></mml:mstyle></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left"><mml:mspace width="9em"/><mml:mo>&#x000d7;</mml:mo><mml:mrow><mml:mfenced open="[" close="]"><mml:mrow><mml:mi>B</mml:mi><mml:mfenced open="(" close=")"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>x</mml:mi><mml:mo stretchy="true">&#x000af;</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>&#x02026;</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>x</mml:mi><mml:mo stretchy="true">&#x000af;</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mstyle displaystyle="true"><mml:munderover><mml:mrow><mml:mo mathsize="big">&#x0220f;</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:mfenced open="(" close=")"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>x</mml:mi><mml:mo stretchy="true">&#x000af;</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mfenced open="(" close=")"><mml:mrow><mml:mn>1</mml:mn><mml:mo>-</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mfenced open="(" close=")"><mml:mrow><mml:mn>1</mml:mn><mml:mo>-</mml:mo><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>x</mml:mi><mml:mo stretchy="true">&#x000af;</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:mrow></mml:mstyle></mml:mrow></mml:mfenced></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula></p><p>As an example consider the Boolean function <italic>B</italic>&#x02009;'&#x02009;(<italic>a</italic>,&#x02009;<italic>b</italic>)&#x02009;=&#x02009;<italic>a</italic>&#x000a0;OR&#x000a0;<italic>b</italic>. The BooleCube interpolation is <italic>C</italic>[<italic>B</italic>&#x02009;']&#x02009;=&#x02009;<italic>a</italic>&#x02009;+&#x02009;<italic>b</italic>&#x02009;-&#x02009;<italic>ab</italic> which satisfies <italic>C</italic>[<italic>B</italic>&#x02009;'&#x02009;(<italic>a</italic>,&#x02009;<italic>b</italic>)] =&#x02009;<italic>B</italic>&#x02009;'&#x02009;(<italic>a</italic>,&#x02009;<italic>b</italic>) for all (<italic>a</italic>,<italic>b</italic>) &#x003f5; {0,1}<sup>2</sup> and is smooth (Figure&#x000a0;<xref ref-type="fig" rid="F1">1</xref>D).</p><p>Wittmann et al. [<xref ref-type="bibr" rid="B4">4</xref>] also extended this formalism to include a switch-like behavior of network nodes by modifying the inputs to the BooleCube interpolation by a sigmoid-shaped Hill function <italic>f</italic>(<italic>x</italic>)&#x02009;=&#x02009;<italic>x</italic><sup><italic>n</italic></sup> / (<italic>x</italic><sup><italic>n</italic></sup>&#x02009;+&#x02009;<italic>k</italic><sup><italic>n</italic></sup>) leading to HillCubes and, with a normalized sigmoid function <italic>f</italic>(<italic>x</italic>)&#x02009;=&#x02009;(<italic>x</italic><sup><italic>n</italic></sup>/(<italic>x</italic><sup><italic>n</italic></sup>&#x02009;+&#x02009;<italic>k</italic><sup><italic>n</italic></sup>))/(1/(1&#x02009;+&#x02009;<italic>k</italic><sup><italic>n</italic></sup>)), to normalized HillCubes (Figure&#x000a0;<xref ref-type="fig" rid="F1">1</xref>E).</p><p>These high degree polynomial interpolations of Boolean functions are implemented in the Matlab package Odefy [<xref ref-type="bibr" rid="B6">6</xref>]. While the SQUAD model can be simulated efficiently even for complex network topologies, Odefy&#x02019;s implementation of the polynomial interpolation exhibits a time complexity in &#x003a9;(2<sup><italic>n</italic></sup>) (where <italic>n</italic> is the number of inputs to the node with the most inputs) for the creation of the model as well as for its simulation.</p><p>In extension of such approaches we show how a tree data structure to store the functions of the network leads to a straightforward and efficient way to calculate the polynomial interpolation for almost any example of practical importance, thereby greatly expanding the range of networks that can be simulated and analyzed in reasonable time using this model. Since semi-quantitative models allow for a range of new analysis techniques such as sensitively quantifying the basins of attraction of the stable states or the influence of noise on network behavior, this paves the way for additional insights into network dynamics. We demonstrate this new algorithm as a part of Jimena, a new Java GRN simulation framework which focuses on computational efficiency and a modularized architecture to facilitate the development and testing of new algorithms and models surrounding GRNs.</p></sec><sec><title>Implementation</title><sec><title>A recursive algorithm to calculate the BooleCube polynomial</title><p>To tackle the space and time complexity issues of the polynomial interpolation present in previous implementations, we use simple Boolean trees to represent the Boolean functions of the network. In a Boolean tree (Figure&#x000a0;<xref ref-type="fig" rid="F2">2</xref>), the leaves (i.e. nodes without ingoing connections such as <italic>x</italic><sub>1</sub> in Figure&#x000a0;<xref ref-type="fig" rid="F2">2</xref>) are inputs to the function, and the non-leaf nodes are unary or binary Boolean gates (such as AND in Figure&#x000a0;<xref ref-type="fig" rid="F2">2</xref>). Each Boolean gate combines the values from its ingoing connections to an outgoing line in accordance with the Boolean function (e.g. AND, OR or NOT) the gate represents. The value of the root node, i.e. the unique node without outgoing connections to other nodes, determines the value of the function.</p><fig id="F2" position="float"><label>Figure 2</label><caption><p><bold>A Boolean tree for the function </bold><bold><italic>B</italic></bold><sub><bold>1</bold></sub><bold><italic>(x</italic></bold><sub><bold>1</bold></sub><bold>,&#x02009;</bold><bold><italic>x</italic></bold><sub><bold>2</bold></sub><bold>,&#x02009;</bold><bold><italic>x</italic></bold><sub><bold>3</bold></sub><bold>)&#x02009;=&#x02009;(</bold><bold><italic>NOT&#x000a0;x</italic></bold><sub><bold>1</bold></sub><bold>)&#x000a0;</bold><bold><italic>OR</italic></bold><bold><italic>&#x000a0;(x</italic></bold><sub><bold>2</bold></sub><bold>&#x000a0;AND&#x000a0;</bold><bold><italic>x</italic></bold><sub><bold>3</bold></sub><bold>).</bold> Input variables <italic>x</italic><sub><italic>i</italic></sub> are connected by Boolean operators. The OR node is the root of the tree, i.e. its value determines the value of the function represented by the tree.</p></caption><graphic xlink:href="1471-2105-14-306-2"/></fig><p>Boolean trees can be straightforwardly created in linear time by parsing the Boolean expression which defines a Boolean function, and the function represented by the tree can be interpolated very quickly using a recursive algorithm which we will describe in detail below.</p><p>While Odefy, which uses exhaustive value tables stored as multidimensional arrays to represent the functions, needs a space and time in &#x00398;(2<sup><italic>N</italic></sup>) to store a function where <italic>N</italic> is its arity, a Boolean tree guarantees a space requirement in <inline-formula><mml:math id="M2" name="1471-2105-14-306-i2" overflow="scroll"><mml:mi mathvariant="script">O</mml:mi></mml:math></inline-formula>(<italic>E</italic>) where <italic>E</italic> is the length (in characters) of the Boolean expression used to input the desired Boolean function. Jimena&#x02019;s time complexity can therefore be minimized by minimizing the description length of the Boolean functions or by minimizing the Boolean trees, respectively. This difference in time complexity between Odefy and Jimena is of high practical importance, since Boolean functions that appear in today&#x02019;s GRNs can almost exclusively be described by Boolean expressions of moderate length. For most GRN design patterns (e.g. activator-inhibitor-patterns) we even get functions for which their expression length <italic>E</italic> is in O(<italic>N</italic>). A plethora of published networks are constructed using these patterns. These may feature nodes with more than ten inputs per node, for example the floral organ development network presented in [<xref ref-type="bibr" rid="B7">7</xref>], the automatically generated regulatory network for arthritis therapy responders from [<xref ref-type="bibr" rid="B8">8</xref>] or the plant immunity network from [<xref ref-type="bibr" rid="B9">9</xref>] which we will analyze below.</p><p>In addition to the speed up of the creation of the GRN, the tree structure also expedites the calculation of BooleCube (and therefore HillCube) interpolations since we can essentially apply the interpolation separately to all logic gates of the function and recursively evaluate the tree from the root node to the leaves. For a more precise description of the algorithm consider a regulatory network with nodes {<italic>x</italic><sub>1</sub>,&#x02026;,<italic>x</italic><sub><italic>n</italic></sub>}. May the Boolean function <italic>B</italic><sub><italic>k</italic></sub>(&#x02026;) of a node <italic>x</italic><sub><italic>k</italic></sub> be given by a Boolean tree consisting of nodes {<italic>n</italic><sub>1</sub>,&#x02026;,<italic>n</italic><sub><italic>m</italic></sub>}. Note, that as shown in Figure&#x000a0;<xref ref-type="fig" rid="F2">2</xref>, these <italic>n</italic><sub><italic>i</italic></sub> represent binary or unary Boolean gates or inputs to the function <italic>B</italic><sub><italic>k</italic></sub>(&#x02026;). For each function in the network we get a separate tree and therefore a separate set {<italic>n</italic><sub>1</sub>,&#x02026;,<italic>n</italic><sub><italic>m</italic></sub>} .</p><p>To illustrate the relationship between {<italic>x</italic><sub>1</sub>,&#x02026;,<italic>x</italic><sub><italic>n</italic></sub>} and {<italic>n</italic><sub>1</sub>,&#x02026;,<italic>n</italic><sub><italic>m</italic></sub>} consider the network {<italic>x</italic><sub>1</sub>,<italic>x</italic><sub><italic>2</italic></sub>} where <italic>B</italic><sub>1</sub>(<italic>x</italic><sub>1</sub>,<italic>x</italic><sub>2</sub>)&#x02009;=&#x02009;<italic>x</italic><sub>1</sub> AND <italic>x</italic><sub>2</sub> and <italic>B</italic><sub>2</sub>(<italic>x</italic><sub>1</sub>,<italic>x</italic><sub>2</sub>)&#x02009;=&#x02009;<italic>x</italic><sub>1</sub> OR <italic>x</italic><sub>2</sub>. A possible Boolean tree for the function <italic>B</italic><sub>1</sub> could then be given by the nodes <italic>n</italic><sub>1</sub>,<italic>n</italic><sub>2</sub>,<italic>n</italic><sub>3</sub>, where the root node <italic>n</italic><sub>1</sub> is an AND node with the leaves <italic>n</italic><sub>2</sub> and <italic>n</italic><sub>3</sub>, <italic>n</italic><sub>2</sub> is an input node representing <italic>x</italic><sub>1</sub> and <italic>n</italic><sub>3</sub> is an input node representing <italic>x</italic><sub>2</sub>.</p><p>We call the function given by the subtree whose root is <italic>n</italic><sub><italic>i</italic></sub><italic>f</italic><sub><italic>i</italic></sub>, where <italic>f</italic><sub><italic>i</italic></sub>(<italic>x</italic><sub><italic>j</italic></sub>)&#x02009;=&#x02009;<italic>x</italic><sub><italic>j</italic></sub> for some <italic>x</italic><sub><italic>j</italic></sub> for all input nodes. If a node <italic>n</italic><sub><italic>i</italic></sub> is not an input node to the network we call its binary or unary logic gate&#x02009;&#x02297;&#x02009;<sub><italic>i</italic></sub>. In our example Boolean tree from above we would get <italic>f</italic><sub>2</sub>(<italic>x</italic><sub>1</sub>)&#x02009;=&#x02009;<italic>x</italic><sub>1</sub>, <italic>f</italic><sub>3</sub>(<italic>x</italic><sub>2</sub>)&#x02009;=&#x02009;<italic>x</italic><sub>2</sub>, <italic>f</italic><sub>1</sub>(<italic>x</italic><sub>1</sub>)&#x02009;=&#x02009;<italic>x</italic><sub>2</sub>&#x02009;=&#x02009;<italic>x</italic><sub>1</sub> AND <italic>x</italic><sub>2</sub> and&#x02009;&#x02297;&#x02009;<sub>1</sub>&#x02009;=&#x02009;AND.</p><p>For an arbitrary Boolean function <italic>f</italic>&#x02009;:&#x02009;{0,&#x02009;1}<sup><italic>&#x003c4;</italic></sup>&#x02009;&#x02192;&#x02009;{0,&#x02009;1}, <italic>C</italic>[<italic>f</italic>] denotes its BooleCube interpolation. We can then construct a recursive term for the interpolation <italic>C</italic>[<italic>f</italic><sub><italic>i</italic></sub>] of a node <italic>n</italic><sub><italic>i</italic></sub> &#x02019;s function <italic>f</italic><sub><italic>i</italic></sub> using the following rules:</p><p>If <italic>n</italic><sub><italic>i</italic></sub> represents an input node of the tree for which <italic>f</italic><sub><italic>i</italic></sub>(<italic>x</italic><sub><italic>j</italic></sub>)&#x02009;=&#x02009;<italic>x</italic><sub><italic>j</italic></sub> we set <italic>C</italic>[<italic>f</italic><sub><italic>i</italic></sub>]&#x02009;&#x02261;&#x02009;<italic>x</italic><sub><italic>j</italic></sub></p><p>If <italic>n</italic><sub><italic>i</italic></sub> is a unary negating node whose input is a node <italic>n</italic><sub><italic>j</italic></sub>, we set</p><p><disp-formula><mml:math id="M3" name="1471-2105-14-306-i3" overflow="scroll"><mml:mrow><mml:mi>C</mml:mi><mml:mfenced open="[" close="]"><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mfenced><mml:mo>=</mml:mo><mml:mi>C</mml:mi><mml:mfenced open="[" close="]"><mml:mrow><mml:msub><mml:mrow><mml:mo>&#x02297;</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mfenced open="(" close=")"><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mfenced></mml:mrow></mml:mfenced><mml:mo>&#x02261;</mml:mo><mml:mi>C</mml:mi><mml:mfenced open="[" close="]"><mml:msub><mml:mrow><mml:mo>&#x02297;</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mfenced><mml:mfenced open="(" close=")"><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mfenced><mml:mo>=</mml:mo><mml:mi>C</mml:mi><mml:mfenced open="[" close="]"><mml:mi>&#x000ac;</mml:mi></mml:mfenced><mml:mfenced open="(" close=")"><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mfenced><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>-</mml:mo><mml:mi>C</mml:mi><mml:mfenced open="[" close="]"><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mfenced></mml:mrow></mml:math></disp-formula></p><p>If <italic>n</italic><sub><italic>i</italic></sub> is a binary node with two inputs <italic>n</italic><sub><italic>j</italic>1</sub> and <italic>n</italic><sub><italic>j</italic>2</sub> whose functions are <italic>f</italic><sub><italic>j</italic>1</sub> and <italic>f</italic><sub><italic>j</italic>2</sub> we set</p><p><disp-formula><mml:math id="M4" name="1471-2105-14-306-i4" overflow="scroll"><mml:mrow><mml:mtable><mml:mtr><mml:mtd columnalign="left"><mml:mi>C</mml:mi><mml:mfenced open="[" close="]"><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mfenced><mml:mo>=</mml:mo><mml:mi>C</mml:mi><mml:mfenced open="[" close="]"><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>&#x02297;</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mo>&#x02261;</mml:mo><mml:mi>C</mml:mi><mml:mfenced open="[" close="]"><mml:mo>&#x02297;</mml:mo></mml:mfenced><mml:mfenced open="(" close=")"><mml:mrow><mml:mi>C</mml:mi><mml:mfenced open="[" close="]"><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub></mml:mfenced><mml:mo>,</mml:mo><mml:mi>C</mml:mi><mml:mfenced open="[" close="]"><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub></mml:mfenced></mml:mrow></mml:mfenced></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left"><mml:mspace width="2.5em"/><mml:mo>=</mml:mo><mml:munderover><mml:mrow><mml:mstyle displaystyle="true"><mml:mo mathsize="big">&#x02211;</mml:mo></mml:mstyle></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>a</mml:mi><mml:mo stretchy="true">&#x000af;</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:munderover><mml:mrow><mml:mstyle displaystyle="true"><mml:mo mathsize="big">&#x02211;</mml:mo></mml:mstyle></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>a</mml:mi><mml:mo stretchy="true">&#x000af;</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:mfenced open="(" close=")"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>a</mml:mi><mml:mo stretchy="true">&#x000af;</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>&#x02297;</mml:mo><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>a</mml:mi><mml:mo stretchy="true">&#x000af;</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mo>&#x022c5;</mml:mo><mml:munderover><mml:mrow><mml:mstyle displaystyle="true"><mml:mo mathsize="big">&#x0220f;</mml:mo></mml:mstyle></mml:mrow><mml:mrow><mml:mi>&#x003c6;</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:munderover><mml:mi>&#x003be;</mml:mi><mml:mfenced open="(" close=")"><mml:mrow><mml:mi>C</mml:mi><mml:mfenced open="[" close="]"><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>&#x003c6;</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub></mml:mfenced><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>a</mml:mi><mml:mo stretchy="true">&#x000af;</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>&#x003c6;</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mspace width="0.25em"/></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula></p><p>where &#x003be;(<italic>&#x003b1;,&#x003b2;</italic>) is an abbreviation for <italic>&#x003b1;&#x003b2;</italic>&#x02009;+&#x02009;(1-<italic>&#x003b1;</italic>)(1-<italic>&#x003b2;</italic>). Notice that this term collapses to <italic>f</italic><sub><italic>j</italic>1</sub><italic>f</italic><sub><italic>j</italic>2</sub> if&#x02009;&#x02297;&#x02009;<sub><italic>i</italic></sub>&#x02009;=&#x02009;&#x02227; (i.e. the logic gate is an AND) and <inline-formula><mml:math id="M5" name="1471-2105-14-306-i5" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>-</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>&#x022c5;</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> if&#x02009;&#x02297;&#x02009;<sub><italic>i</italic></sub>&#x02009;=&#x02009;&#x02227; (i.e. the logic gate is an OR), both of which can be calculated very efficiently. The <italic>C</italic>[&#x02026;] parts of the terms above are then evaluated using the same rules until all branches of the recursion have reached an input node.</p><p>If we apply this algorithm to the root node of the network we get the interpolation <italic>C</italic>[<italic>B</italic><sub><italic>k</italic></sub>] of the function <italic>B</italic><sub><italic>k</italic></sub>. An overview of the algorithm written in pseudo code as well as a proof that the result of this algorithm is identical to the high degree polynomial defined in [<xref ref-type="bibr" rid="B6">6</xref>] can be found in Additional file <xref ref-type="supplementary-material" rid="S1">1</xref>.</p><p>For our example network we get <italic>C</italic>[<italic>f</italic><sub>1</sub>(<italic>x</italic><sub>1</sub>,&#x02009;<italic>x</italic><sub>2</sub>)]&#x02009;=&#x02009;<italic>C</italic>[<italic>AND</italic>](<italic>f</italic><sub>2</sub>(<italic>x</italic><sub>1</sub>),&#x02009;<italic>f</italic><sub>3</sub>(<italic>x</italic><sub>2</sub>))&#x02009;=&#x02009;<italic>f</italic><sub>2</sub>(<italic>x</italic><sub>1</sub>)&#x02009;&#x022c5;&#x02009;<italic>f</italic><sub>3</sub>(<italic>x</italic><sub>2</sub>)&#x02009;=&#x02009;<italic>x</italic><sub>1</sub>&#x02009;&#x022c5;&#x02009;<italic>x</italic><sub>2</sub>. As a second example consider the function <italic>B</italic><sub>1</sub> (Figure&#x000a0;<xref ref-type="fig" rid="F2">2</xref>). Traversing the tree starting from the root node <italic>n</italic><sub><italic>OR</italic></sub> we get <italic>C</italic>[<italic>B</italic><sub>1</sub>]&#x02009;=&#x02009;<italic>C</italic>[<italic>f</italic><sub><italic>OR</italic></sub>]&#x02009;=&#x02009;<italic>C</italic>[<italic>f</italic><sub><italic>NOT</italic></sub>]&#x02009;+&#x02009;<italic>C</italic>[<italic>f</italic><sub><italic>AND</italic></sub>]&#x02009;-&#x02009;<italic>C</italic>[<italic>f</italic><sub><italic>NOT</italic></sub>]<italic>C</italic>[<italic>f</italic><sub><italic>AND</italic></sub>]&#x02009;=&#x02009;(1&#x02009;-&#x02009;<italic>x</italic><sub>1</sub>)&#x02009;+&#x02009;<italic>x</italic><sub>2</sub><italic>x</italic><sub>3</sub>&#x02009;-&#x02009;(1&#x02009;-&#x02009;<italic>x</italic><sub>1</sub>)<italic>x</italic><sub>2</sub><italic>x</italic><sub>3</sub>.</p></sec><sec><title>Obtaining the stable steady states for discrete models from the Boolean tree</title><p>As a side effect, Boolean tree data structures instead of value tables also expedite and simplify the creation of binary decision diagrams (BDDs) equivalent to the Boolean functions of the network (see [<xref ref-type="bibr" rid="B10">10</xref>] for a comprehensive review of BDDs and their algorithms).</p><p>BDDs, whose algorithmic potential was first investigated by Bryant et al. [<xref ref-type="bibr" rid="B11">11</xref>], represent Boolean functions in a rooted, directed and acyclic graph. The structure and the evaluation of BDDs is explained in Figure&#x000a0;<xref ref-type="fig" rid="F3">3</xref>. Common problems surrounding Boolean functions such as finding all solutions satisfying a given expression can efficiently solved once a BDD representation has been created using a set of standard algorithms [<xref ref-type="bibr" rid="B11">11</xref>], which is not possible with Boolean trees.</p><fig id="F3" position="float"><label>Figure 3</label><caption><p><bold>A binary decision diagram for the function (a OR b) AND (b OR c) AND (a OR c).</bold> Evaluation starts at the node &#x0201c;<bold>a</bold>&#x0201d;, which does <bold><italic>not</italic></bold> feature any ingoing connections from other nodes. If the value of the node is 1, the solid line is followed, if it is 0, the dashed line is followed. For the input values a&#x02009;=&#x02009;c&#x02009;=&#x02009;1 and b&#x02009;=&#x02009;0 one would go down from the &#x0201c;<bold>a</bold>&#x0201d; node to the right &#x0201c;<bold>b</bold>&#x0201d; node, on to the &#x0201c;<bold>c</bold>&#x0201d; node and finally along the solid line to the &#x0201c;true&#x0201d; node. This corresponds to (1 OR 0) AND (0 OR 1) AND (1 OR 1)&#x02009;=&#x02009;1 AND 1 AND 1&#x02009;=&#x02009;1 (true).</p></caption><graphic xlink:href="1471-2105-14-306-3"/></fig><p>A possible application of BDDs is the search for all stable steady states (SSS) in discrete models, i.e. network states which reproduce themselves in each following step of a discrete simulations. In contrast, a temporary state will be left if the system is simulated. The calculated steady states can be enumerated and applied in systems biology (e.g. [<xref ref-type="bibr" rid="B9">9</xref>], reviewed in [<xref ref-type="bibr" rid="B12">12</xref>]). Furthermore, BDDs based search algorithms and random sampling algorithms to approximate the stable states in continuous networks have been explored ([<xref ref-type="bibr" rid="B3">3</xref>,<xref ref-type="bibr" rid="B2">2</xref>]).</p><p>If <italic>B</italic><sub><italic>i</italic></sub> are the Boolean functions defining a network consisting of the nodes <italic>x</italic><sub><italic>i</italic></sub>, a network state <italic>x</italic><sub><italic>i</italic></sub><italic>,</italic>&#x02026;,<italic>x</italic><sub><italic>n</italic></sub> is a stable steady state [<xref ref-type="bibr" rid="B3">3</xref>] by definition if and only if <inline-formula><mml:math id="M6" name="1471-2105-14-306-i6" overflow="scroll"><mml:mrow><mml:mspace width="0.25em"/><mml:msub><mml:mrow><mml:mi mathvariant="normal">&#x0039b;</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mfenced open="(" close=")"><mml:mrow><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mfenced open="(" close=")"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>&#x02026;</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi mathvariant="italic">true</mml:mi></mml:mrow></mml:math></inline-formula> where <italic>x</italic><sub><italic>i,j</italic></sub><italic>&#x02208;</italic>{<italic>x</italic><sub><italic>i</italic></sub><italic>,</italic>&#x02026;,<italic>x</italic><sub><italic>n</italic></sub>} is the <italic>j</italic>-th input to the function <italic>B</italic><sub><italic>i</italic></sub> . In other words, all Boolean functions must evaluate to the value which their target node already holds. In common BDD frameworks, such as the JavaBDD framework [<xref ref-type="bibr" rid="B13">13</xref>] which is used by Jimena, BDDs can be constructed by combining elementary BDDs (e.g. BDDs equivalent to the Boolean function consisting of the value of a single input variable) using logical operators such as AND or NOT. For example, to construct a BDD for the function <italic>B</italic>&#x02009;'&#x02009;(<italic>a</italic>,&#x02009;<italic>b</italic>)&#x02009;=&#x02009;<italic>a</italic>&#x000a0;OR&#x000a0;<italic>b</italic> one would create the BDDs <italic>BDD</italic>(<italic>a</italic>) and <italic>BDD</italic>(<italic>b</italic>) for the inputs <italic>a</italic> and <italic>b</italic>, and use the framework to contruct <italic>BDD</italic><sub><italic>OR</italic></sub>(<italic>BDD</italic>(<italic>a</italic>),<italic>BDD</italic>(<italic>b</italic>)) where <italic>BDD</italic><sub><italic>OR</italic></sub> constructs the logical OR of two BDDs.</p><p>Recursively traversing the Boolean tree of the functions <italic>B</italic><sub><italic>i</italic></sub>, the BDDs of these functions can be straightforwardly constructed in the framework by the synthesis method described above, and then combined to a BDD for the expression <inline-formula><mml:math id="M7" name="1471-2105-14-306-i7" overflow="scroll"><mml:mrow><mml:mspace width="0.25em"/><mml:msub><mml:mrow><mml:mi mathvariant="normal">&#x0039b;</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mfenced open="(" close=")"><mml:mrow><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mfenced open="(" close=")"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>&#x02026;</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mtext mathvariant="italic">true</mml:mtext></mml:mrow></mml:math></inline-formula>. All satisfying assignments for this equation, which are identical to the stable steady states of the network, can then be found by standard algorithms in the BDD framework.</p><p>In essence, Boolean trees are necessary to speed up the simulation of continuous networks, while BDDs are essentials for the efficient calculation of SSS.</p></sec></sec><sec><title>Results and discussion</title><p>A jar-library version of Jimena, its sources code, a ready-to-use Eclipse workspace including a commented usage example, further documentation and example networks are available [<xref ref-type="bibr" rid="B14">14</xref>].</p><sec><title>Speed up of the BooleCube calculation</title><p>While it takes a time in &#x00398;(<italic>N</italic>&#x022c5;2<sup><italic>N</italic></sup>) to compute previous implementations of the polynomial interpolation, the tree algorithm runs in a time in <inline-formula><mml:math id="M8" name="1471-2105-14-306-i8" overflow="scroll"><mml:mi mathvariant="script">O</mml:mi></mml:math></inline-formula>(<italic>E</italic>) (where <italic>E</italic> is the description length of the Boolean function) since the (at most second degree) polynomials of each node can be evaluated in <inline-formula><mml:math id="M9" name="1471-2105-14-306-i9" overflow="scroll"><mml:mi mathvariant="script">O</mml:mi></mml:math></inline-formula>(1) and the number of nodes is in <inline-formula><mml:math id="M10" name="1471-2105-14-306-i10" overflow="scroll"><mml:mi mathvariant="script">O</mml:mi></mml:math></inline-formula>(<italic>E</italic>). This also implies that a GRN given by a set of Boolean expressions can be interpolated, and therefore simulated, in a time proportional to the description length of the network.</p><p>To benchmark the time needed to simulate a network with a given node degree we used a scalable artificial network topology which features 2.5<italic>n</italic>-5 interactions and a maximum degree of <italic>n</italic> for <italic>n</italic> nodes (see Additional file <xref ref-type="supplementary-material" rid="S1">1</xref> for a detailed definition of the network). The simulation was run for 10 simulation-time seconds and the normalized HillCube mode [<xref ref-type="bibr" rid="B6">6</xref>] was used in Jimena and Odefy.</p><p>Directly comparing the simulation speed of Odefy and Jimena is not trivial since the time needed by Odefy to simulate a network for a given time t does not depend on this parameter, since the simulation accuracy decreases with higher time t simulated.</p><p>Jimena, on the other hand, uses a standard fixed-step forth-order Runge&#x02013;Kutta method to simulate the networks, hence its performance greatly depends on the step size of this solving method. For Figure&#x000a0;<xref ref-type="fig" rid="F4">4</xref> we therefore scaled the time needed by Jimena such that the data series coincide for networks with 4 nodes. Without the scaling Jimena takes about 20&#x000a0;ms for the simulation with a step size of 1&#x000a0;ms. The experimental data confirm the exponential increase in calculation time for Odefy and a linear one for Jimena. A separate benchmark for the model creation time yielded similar results.</p><fig id="F4" position="float"><label>Figure 4</label><caption><p><bold>Simulation time for a continuous model.</bold> x-axis: number of involved nodes. y-axis: Time (in seconds) to simulate a standardized network with the given number of nodes. Note that in all figures the number of nodes refers to the number of actual network nodes x<sub>i</sub> as opposed to the number of nodes in the Boolean tree. To highlight the time complexity of the different calculation methods, the data series are scaled to coincide for a network with 4 nodes. Actual simulation times for 4 nodes: Jimena (red)&#x02009;=&#x02009;0.019&#x000a0;s, Odefy (blue)&#x02009;=&#x02009;0.040&#x000a0;s, Squad (green)&#x02009;=&#x02009;0.046&#x000a0;s. The Additional file <xref ref-type="supplementary-material" rid="S1">1</xref> explains the definition of the network for a given number of nodes.</p></caption><graphic xlink:href="1471-2105-14-306-4"/></fig><p>Since we chose test networks for which analogous activator-inhibitor-networks could be constructed, we were also able to benchmark the simulation of the equivalent networks using the octave code obtained from the SQUAD Export-to-Octave function. As one would expect from the design of the differential equations, the integration of the ODEs from the SQUAD model exhibits a linear time complexity with respect to the maximum degree of the network nodes.</p><p>While this example shows Jimenas performance for high node degrees, it does not cover networks with large numbers of nodes. We therefore compared the runtime behavior of BooleCube interpolations in Odefy and Jimena in small to large size networks created by the random Erd&#x00151;s&#x02013;R&#x000e9;nyi paradigm, where a connection between nodes are set with equal probability, and by the random scale-free paradigm, where the node degree distributions follows a power law, i.e. the number of network nodes with <italic>k</italic> connections to other nodes is proportional to <italic>k</italic><sup>-&#x003bb;</sup> where &#x003bb; is a constant usually between 2 and 3. It has been established that a large majority of naturally occurring networks are scale-free (see [<xref ref-type="bibr" rid="B15">15</xref>] for a review).</p><p>The run times (creation and simulation) are plotted in Figure&#x000a0;<xref ref-type="fig" rid="F5">5</xref>. Note how Odefy performs especially unfavorably for scale-free networks, which by definition tend to contain nodes with very high degrees, while Jimena&#x02019;s run time reacts benignly to increases in node degree, number of connections and number of nodes. The simulation of scale-free networks with 70 nodes or more did not terminate in Odefy even after runtimes of several hours. Additional benchmarking of large HillCube and normalized HillCube networks yielded almost identical results.</p><fig id="F5" position="float"><label>Figure 5</label><caption><p><bold>BooleCube network performance of Jimena and Odefy.</bold> Random Erd&#x00151;s&#x02013;R&#x000e9;nyi and scale-free networks with a given number of nodes <bold>n</bold> and 3&#x000b7;n interactions (<italic>arrows</italic>) were simulated for 10&#x000a0;seconds with a step size of 0.05&#x000a0;s in Jimena. The scale-free networks were grown using a preferential attachment mechanism. All simulations were aborted after a maximum of 1&#x000a0;minute calculation time.</p></caption><graphic xlink:href="1471-2105-14-306-5"/></fig><p>Since SQUAD, BooleanNet and other simulation frameworks cannot simulate BooleCube networks, they are not included in this comparison. With the limitation to networks consisting only of simple activating or inhibiting influences, SQUADs runtime behavior is similar to that of Jimena (cf. Figure&#x000a0;<xref ref-type="fig" rid="F4">4</xref>).</p></sec><sec><title>Speed of the SSS calculation</title><p>Since the number of SSS in discrete models can be in &#x00398;(2<sup><italic>E</italic></sup>) this is also the minimum time complexity of a search algorithm. To benchmark our implementation we used the same scalable test topology as before which features 2<sup>(<italic>n</italic>-2)/2</sup> SSS for <italic>n</italic> nodes. In Figure&#x000a0;<xref ref-type="fig" rid="F6">6</xref> one can see that the time needed to determine the SSS stays very slow even for high node degrees. It only begins to increase for high numbers of solutions (40 nodes: 524,288 solutions) where it grows linearly with the number of solutions. Note that the exponential increase of the number of SSS with the size of the network is a artificial worst case scenario and that for evolutionary reasons, many GRN only feature a limited number of stable steady states.</p><fig id="F6" position="float"><label>Figure 6</label><caption><p><bold>Stable state calculation time for a discrete model.</bold> x-axis: number of involved nodes. y-axis: Time (in milliseconds) needed to determine the stable states of a standardized network with the given number of nodes. The Additional file <xref ref-type="supplementary-material" rid="S1">1</xref> explains the definition of the network for a given number of nodes.</p></caption><graphic xlink:href="1471-2105-14-306-6"/></fig><p>For medium sized random scale-free networks (100 nodes, 200 interactions, 100 unique networks) we obtained a mean run time of 3890&#x000a0;ms (median 1401&#x000a0;ms). Further experimentation showed that the calculation of the stable steady states using JavaBDD as a BDD framework is usually possible for random networks until about 150-200 network nodes and 500 interactions on standard hardware, with the limit being the main memory available in the computational environment.</p><p>Since larger networks for which Jimena takes a measurable time to calculate the SSS cannot be loaded in Odefy, we could not directly compare the two frameworks in this respect.</p><p>This time complexity makes the search feasible even for larger and highly interconnected networks which could not even be loaded using a multidimensional array implementation.</p></sec><sec><title>Multithreading</title><p>To determine as many stable steady states of a network as possible for continuous models such as the Odefy and SQUAD models, it is necessary to exhaustively sample a large state space. This task can be greatly expedited by distributing the sampling to multiple CPU cores as done automatically by the search algorithms implemented in Jimena.</p><p>Since Jimena&#x02019;s tree-based networks are very lightweight compared to multidimensional array implementations, they can be copied quickly and many of them can be held in memory at the same time. This not only allows for an excellent scaling behavior on commonly used multi-core systems, resulting for example in an almost 8 times higher sampling rate on an 8 core system, but also facilitates the efficient comparison of variants of a given network to analyze its stability with regard to certain manipulations such as null mutations [<xref ref-type="bibr" rid="B7">7</xref>]. The usage of the stable state searching algorithm is explained the aforementioned commented usage example. As applied examples we studied network behavior in plants and bacteria.</p></sec><sec><title>Applied example: Arabidopsis thaliana development</title><p>The first example takes the plant <italic>Arabidopsis thaliana</italic> flower organ specification network from [<xref ref-type="bibr" rid="B7">7</xref>]. It concerns A. thaliania development and makes use of Boolean functions instead of mere activating and inhibiting influences and features nodes with a larger number of inputs. Floral homeotic protein APETALA 1 is a central transcription factor in this network. It promotes early floral meristem identity in synergy with LEAFY and regulates positively the B class homeotic proteins APETALA3 and PISTILLATA with the cooperation of LEAFY and its co-regulator UFO (unusual floral organs). The network we investigate here [<xref ref-type="bibr" rid="B7">7</xref>] is a discrete model on the ABC homeotic floral genes, summarizing also non-ABC gene interactions to a dynamical floral organ cell fate model.</p><p>We simulated the network for 10 simulation-time seconds using the normalized HillCube (NHC) model on a standard 2.67&#x000a0;GHz CPU. For the step size of Jimena&#x02019;s ODE solver we tested 0.01&#x000a0;s and 0.1&#x000a0;s. Even with a step size of 0.1&#x000a0;s, the absolute error of the simulation is in the order of 10<sup>-5</sup> when simulating 10&#x000a0;seconds and much lower when searching for a stable state, which should already be more than enough for practical applications. To benchmark the original SQUAD ODEs we used the simplified activator-inhibitor version of the network shown in Figure&#x000a0;<xref ref-type="fig" rid="F1">1</xref> from [<xref ref-type="bibr" rid="B7">7</xref>], although we are aware that in the same article the authors propose a slightly modified version of the standardized qualitative dynamical systems methodology implemented in SQUAD. 10 successive simulations of the network for Jimena, SQUAD and Odefy showed that Odefy needs 467(&#x000b1;2) ms to create the network and additional 583(&#x000b1;4) ms to simulate it, while the SQUAD ODEs are solved in 467(&#x000b1;0.3) ms. With step sizes of 0.1&#x000a0;s and 0.01&#x000a0;s Jimena needs for these two tasks only 3.1(&#x000b1;0.4) ms and 28.2(&#x000b1;0.7) ms respectively (Table&#x000a0;<xref ref-type="table" rid="T1">1</xref>). We used this computational improvement to determine the basins of attraction of the stable states of the network assuming a NHC model based on the Boolean function given in the corrigendum to [<xref ref-type="bibr" rid="B7">7</xref>], a calculation which also benefits greatly from Jimenas automatic multithreading. For the co-regulator UFO we assumed a loop (UFO&#x02009;=&#x02009;UFO) which reproduced the known stable states in Jimenas discrete und NHC model calculations. By simulating the network from 10<sup>6</sup> random initial states we found that although both models are based on the same Boolean functions, interestingly the inflorescence states INF1, INF2, INF3 and INF4 (inflorescence attractors 1-4), whose biological validity has been confirmed by gene expression experiments [<xref ref-type="bibr" rid="B16">16</xref>], are much more unstable in the NHC model, having a combined basin of attraction size of only 0.06% as opposed to 5.1% in the discrete model and 17.6% in the continuous model from [<xref ref-type="bibr" rid="B7">7</xref>] (Table&#x000a0;<xref ref-type="table" rid="T2">2</xref>). In other words, when simulated from 10<sup>6</sup> initial states where the values of the nodes have been chosen randomly from the interval [0,1] only 0.06% of the simulations converge on a state corresponding to a non-flowering phenotype.</p><table-wrap position="float" id="T1"><label>Table 1</label><caption><p>Loading and simulation time in different simulation frameworks</p></caption><table frame="hsides" rules="groups" border="1"><colgroup><col align="left"/><col align="left"/><col align="left"/></colgroup><thead valign="top"><tr><th align="left"><bold>Package</bold></th><th align="left"><bold>Calculation</bold></th><th align="left"><bold>Time (ms)</bold></th></tr></thead><tbody valign="top"><tr><td align="left" valign="bottom">Odefy<hr/></td><td align="left" valign="bottom">Network loading<hr/></td><td align="left" valign="bottom">467(&#x000b1;2)<hr/></td></tr><tr><td align="left" valign="bottom">Odefy<hr/></td><td align="left" valign="bottom">Network simulation<hr/></td><td align="left" valign="bottom">583(&#x000b1;4)<hr/></td></tr><tr><td align="left" valign="bottom">SQUAD<hr/></td><td align="left" valign="bottom">Network simulation<hr/></td><td align="left" valign="bottom">467(&#x000b1;0.3)<hr/></td></tr><tr><td align="left" valign="bottom">Jimena<hr/></td><td align="left" valign="bottom">Network loading<hr/></td><td align="left" valign="bottom">3.7(&#x000b1;0.2)<hr/></td></tr><tr><td align="left" valign="bottom">Jimena<hr/></td><td align="left" valign="bottom">Network simulation (time step: 0.1&#x000a0;s)<hr/></td><td align="left" valign="bottom">3.1(&#x000b1;0.4)<hr/></td></tr><tr><td align="left">Jimena</td><td align="left">Network simulation (time step: 0.01&#x000a0;s)</td><td align="left">28.2(&#x000b1;0.7)</td></tr></tbody></table><table-wrap-foot><p>The <italic>Arabidopsis thaliana</italic> flower organ specification network was loaded and simulated ten times in Odefy, SQUAD and Jimena, the mean calculation time is given in the table.</p></table-wrap-foot></table-wrap><table-wrap position="float" id="T2"><label>Table 2</label><caption><p>Basins of attraction of the A. thaliana development network</p></caption><table frame="hsides" rules="groups" border="1"><colgroup><col align="left"/><col align="left"/><col align="left"/><col align="left"/></colgroup><thead valign="top"><tr><th align="left"><bold>Attractor</bold></th><th align="left"><bold>NHC model (%)</bold></th><th align="left"><bold>Discrete model (%)</bold></th><th align="left"><bold>Continuous model (%)</bold></th></tr></thead><tbody valign="top"><tr><td align="left" valign="bottom">INF1<hr/></td><td align="left" valign="bottom">0.005<hr/></td><td align="left" valign="bottom">1.66<hr/></td><td align="left" valign="bottom">4.74<hr/></td></tr><tr><td align="left" valign="bottom">INF2<hr/></td><td align="left" valign="bottom">0.016<hr/></td><td align="left" valign="bottom">1.66<hr/></td><td align="left" valign="bottom">4.77<hr/></td></tr><tr><td align="left" valign="bottom">INF3<hr/></td><td align="left" valign="bottom">0.010<hr/></td><td align="left" valign="bottom">0.88<hr/></td><td align="left" valign="bottom">4.01<hr/></td></tr><tr><td align="left" valign="bottom">INF4<hr/></td><td align="left" valign="bottom">0.032<hr/></td><td align="left" valign="bottom">0.88<hr/></td><td align="left" valign="bottom">4.06<hr/></td></tr><tr><td align="left" valign="bottom">SEP<hr/></td><td align="left" valign="bottom">0.144<hr/></td><td align="left" valign="bottom">9.91<hr/></td><td align="left" valign="bottom">11.01<hr/></td></tr><tr><td align="left" valign="bottom">PET1<hr/></td><td align="left" valign="bottom">0.477<hr/></td><td align="left" valign="bottom">10.05<hr/></td><td align="left" valign="bottom">12.74<hr/></td></tr><tr><td align="left" valign="bottom">PET2<hr/></td><td align="left" valign="bottom">0.024<hr/></td><td align="left" valign="bottom">0.14<hr/></td><td align="left" valign="bottom">1.89<hr/></td></tr><tr><td align="left" valign="bottom">STM1<hr/></td><td align="left" valign="bottom">74.556<hr/></td><td align="left" valign="bottom">37.4<hr/></td><td align="left" valign="bottom">28.46<hr/></td></tr><tr><td align="left" valign="bottom">STM2<hr/></td><td align="left" valign="bottom">7.920<hr/></td><td align="left" valign="bottom">1.15<hr/></td><td align="left" valign="bottom">6.54<hr/></td></tr><tr><td align="left">CAR</td><td align="left">16.816</td><td align="left">36.25</td><td align="left">21.79</td></tr></tbody></table><table-wrap-foot><p>An NHC model based on the Boolean functions of the corrigendum to [<xref ref-type="bibr" rid="B7">7</xref>] was simulated from 10<sup>6</sup> random initial vectors. The parameters of the Hill function were n&#x02009;=&#x02009;2 and k&#x02009;=&#x02009;0.5 and the decay parameter was &#x003c4;&#x02009;=&#x02009;1 for all nodes. The values for the corresponding discrete and continuous model from the original article are cited from there [<xref ref-type="bibr" rid="B7">7</xref>].</p></table-wrap-foot></table-wrap><p>Using active EMF1 (embryonic flower 1) and TFL1 (terminal flower 1) nodes (i.e. EMF1&#x02009;&#x0003e;&#x02009;0.5 AND TFL1&#x02009;&#x0003e;&#x02009;0.5) as an indicator of an inflorescence state, we then determined the basins of attraction of the same model assuming null mutations for all 42 interactions (arrows) of the network by simulating from 10<sup>4</sup> random start vectors per mutant. The combined basin of attraction size of each mutant stayed below 0.5%, except for a removal of the influence of AP1 (APETALA1) on TFL1 whose mutation directly causes our condition for inflorescence state to fail, leading to a combined basin size of ~3.5%.</p><p>These results corroborate the hypothesis that the inflorescence attractors are transitory in nature, such that small perturbations lead to progress in plant development and cell differentiation arriving at few and robust standard outcomes of floral organs. Furthermore, the low size of the inflorescence basins of attraction of the mutant networks is consistent with a reported strong robustness of <italic>A. thaliana</italic> mutants against a non-flowering phenotype [<xref ref-type="bibr" rid="B17">17</xref>].</p></sec><sec><title>Applied example II: Arabidopsis thaliana immunity and pathogen Pst DC3000</title><p>A second example considers a different area, the immune response of the <italic>Arabidopsis thaliana</italic> plant against gram negative bacterium <italic>Pseudomonas syringae DC3000 pv tomato</italic> and its modulation by cytokines [<xref ref-type="bibr" rid="B9">9</xref>]. Furthermore, this interaction network concerns two organisms, plant and its pathogen and is already due to this fact more complex. The larger Boolean network features 104 nodes and 156 interactions. In particular, using the immune response marker node PR1 the counteracting or synergistic effects of different hormone and cytokine can be modeled. For instance, cytokine enhances immune responses while auxin stimulates growth but mitigates immune defence. A number of further insights were obtained from this network and its analysis including new cytokine mediated regulatory interactions and specific synergism between cytokinin and salicylic acid pathways as well as differences in network responses for fully virulent and mitigated pathogens [<xref ref-type="bibr" rid="B9">9</xref>]. With a step size of 0.1&#x000a0;s and 0.01&#x000a0;s Jimena needs 20.0(&#x000b1;0.4) ms and 193(&#x000b1;3) ms respectively to simulate 10&#x000a0;seconds using the BooleCube model, while SQUAD takes 11.04(&#x000b1;0.02) s. In Odefy the network cannot be loaded due to the high number of inputs to some nodes. Since in Jimena null mutations are part of the computational core, networks can be mutated and restored very quickly. This not only includes the removal of nodes, but also the removal of single interactions between network nodes. We searched for the stable states of the network for all single null mutations (n&#x02009;=&#x02009;156) in the continuous NHC model by randomly sampling the state space with 2000 initial states per mutation, and compared the resulting stable states with the ones obtained by treating the network as a discrete Boolean model. We found that for all mutants and the original network the stable states of the discrete and the NHC model seem to be identical.</p><p>As we expected, the network exhibits a strong robustness against null mutations, with only 2 mutations changing the number of stable states (from 2 to 1). These are the null mutation of the influence of SA (salicylic acid) on ROS (reactive oxygen species) and of ROS on SA where SA is a key hub node of the network and the small cycle SA&#x02009;&#x02192;&#x02009;RO&#x02009;&#x02192;&#x02009;SA is crucial for its number of stable states. For all other mutations (n&#x02009;=&#x02009;154) the changes of the stable states are minor, with only one mutation effecting more than four changed nodes per stable state, namely the removal of ETR/CTR1 (ethylene response / cytosolic serine/threonine kinase constitutive triple response 1)&#x02009;&#x02192;&#x02009;AHP (Histidine-containing phosphotransmitters) which causes five nodes to change, and most single mutations (n&#x02009;=&#x02009;142) leading to no change at all.</p><p>To check whether the number of stable states increases assuming multiple mutations we then determined the stable states for up to 4 null mutations (n&#x02009;&#x02248;&#x02009;2.4&#x022c5;10<sup>7</sup>) in the discrete network model and found that the number of stable states never exceeds 2. Using a single 2.67&#x000a0;GHz CPU core Jimena constructs and analyzes 2,700 mutants per second in this network, and more than 24,000 mutants per second in the <italic>A. thaliana</italic> development network from above (number of interactions&#x02009;=&#x02009;42), which demonstrates its computational efficiency even for complex networks. The result of this analysis hints to the robustness of the network against the emergence of new stable states even when multiple interactions (up to four) are removed. Inbuilt robustness is not a rare phenomenon in biological signaling cascades as independently confirmed from experimental data such as promoter recombination trials in <italic>E. coli</italic>[<xref ref-type="bibr" rid="B18">18</xref>] or the reported phenotypical robustness of <italic>C. albicans</italic> against null mutations of transcriptional regulators [<xref ref-type="bibr" rid="B19">19</xref>]. Additional benefits from robustness for this particular signal cascade include that additional stable states could be detrimental to the latency and efficacy of immune reactions.</p></sec></sec><sec sec-type="conclusions"><title>Conclusion</title><p>Within the last years the size and complexity of discovered genetic regulatory networks has increased substantially, partly due to automated network creation techniques using time series data from methods such as real-time RT-PCR or RNAseq.</p><p>Motivated by current limitations of Odefy (version 1.18, year 2013), the use of tree data structures and corresponding algorithms in Jimena paves the way for the simulation and analysis of more sophisticated networks than possible previously, including those beyond the scope of simple activating and inhibiting influences covered by SQUAD. This may provide additional insight especially with regard to the role of nodes that are influenced by many other nodes, which seem to greatly influence the behavior of many GRNs.</p><p>For an overview of all currently published features of Jimena see Figure&#x000a0;<xref ref-type="fig" rid="F7">7</xref>.</p><fig id="F7" position="float"><label>Figure 7</label><caption><p><bold>Feature overview of the Jimena simulation framework.</bold> Included are all features as of version 160913.</p></caption><graphic xlink:href="1471-2105-14-306-7"/></fig></sec><sec><title>Availability and requirements</title><p>The software, its source code, example data and a tutorial are available from <ext-link ext-link-type="uri" xlink:href="http://stefan-karl.de/jimena/">http://stefan-karl.de/jimena/</ext-link> and <ext-link ext-link-type="uri" xlink:href="http://www.bioinfo.biozentrum.uni-wuerzburg.de/computing/jimena">http://www.bioinfo.biozentrum.uni-wuerzburg.de/computing/jimena</ext-link>. Jimena runs on any operating system (windows, Linux, Mac). Jimena requires Java 7 or above.</p></sec><sec><title>Competing interests</title><p>The authors declare that they have no competing interests.</p></sec><sec><title>Authors&#x02019; contributions</title><p>SK developed, formally verified, implemented and benchmarked the algorithms, contributed ideas and algorithms to the applied examples and wrote the first draft of the manuscript. TD conceptualized and analyzed the applied examples and the biological insights, reviewed and revised the manuscript and led the project. Both authors have read the manuscript and approved the final version.</p></sec><sec sec-type="supplementary-material"><title>Supplementary Material</title><supplementary-material content-type="local-data" id="S1"><caption><title>Additional file 1</title><p>In this document file (.doc) we include a proof summary of the BooleCube interpolation algorithm, the topologies for the benchmarks used and the pseudocode for the interpolation algorithm.</p></caption><media xlink:href="1471-2105-14-306-S1.docx"><caption><p>Click here for file</p></caption></media></supplementary-material></sec></body><back><sec><title>Acknowledgements</title><p>Support by DFG (Da 208/12-1) is gratefully acknowledged.</p></sec><ref-list><ref id="B1"><mixed-citation publication-type="other"><name><surname>Gershenson</surname><given-names>C</given-names></name><article-title>Introduction to random Boolean networks</article-title><source>Workshop and tutorial proceedings, ninth International conference on the simulation and synthesis of living systems (ALife IX)</source><year>2004</year><fpage>160</fpage><lpage>173</lpage></mixed-citation></ref><ref id="B2"><mixed-citation publication-type="journal"><name><surname>Mendoza</surname><given-names>L</given-names></name><name><surname>Xenarios</surname><given-names>I</given-names></name><article-title>A method for the generation of standardized qualitative dynamical systems of regulatory networks</article-title><source>Theor Biol Med Model</source><year>2006</year><volume>3</volume><fpage>13</fpage><pub-id pub-id-type="doi">10.1186/1742-4682-3-13</pub-id><?supplied-pmid 16542429?><pub-id pub-id-type="pmid">16542429</pub-id></mixed-citation></ref><ref id="B3"><mixed-citation publication-type="journal"><name><surname>Di Cara</surname><given-names>A</given-names></name><name><surname>Abhishek</surname><given-names>G</given-names></name><name><surname>De Micheli</surname><given-names>G</given-names></name><name><surname>Xenarios</surname><given-names>I</given-names></name><name><surname>Mendoza</surname><given-names>L</given-names></name><article-title>Dynamic simulation of regulatory networks using SQUAD</article-title><source>BMC Bioinforma</source><year>2007</year><volume>8</volume><fpage>462</fpage><pub-id pub-id-type="doi">10.1186/1471-2105-8-462</pub-id></mixed-citation></ref><ref id="B4"><mixed-citation publication-type="journal"><name><surname>Wittmann</surname><given-names>DM</given-names></name><name><surname>Krumsiek</surname><given-names>J</given-names></name><name><surname>Saez-Rodriguez</surname><given-names>J</given-names></name><name><surname>Lauffenburger</surname><given-names>DA</given-names></name><name><surname>Klamt</surname><given-names>S</given-names></name><name><surname>Theis</surname><given-names>FJ</given-names></name><article-title>Transforming Boolean models to continuous models: methodology and application to T-cell receptor signaling</article-title><source>BMC Syst Biol</source><year>2009</year><volume>3</volume><fpage>98</fpage><pub-id pub-id-type="doi">10.1186/1752-0509-3-98</pub-id><?supplied-pmid 19785753?><pub-id pub-id-type="pmid">19785753</pub-id></mixed-citation></ref><ref id="B5"><mixed-citation publication-type="journal"><name><surname>Albert</surname><given-names>I</given-names></name><name><surname>Thakar</surname><given-names>J</given-names></name><name><surname>Li</surname><given-names>S</given-names></name><name><surname>Zhang</surname><given-names>R</given-names></name><name><surname>Albert</surname><given-names>R</given-names></name><article-title>Boolean network simulations for life scientists</article-title><source>Sour Code Bio Med</source><year>2008</year><volume>3</volume><fpage>16</fpage><pub-id pub-id-type="doi">10.1186/1751-0473-3-16</pub-id></mixed-citation></ref><ref id="B6"><mixed-citation publication-type="journal"><name><surname>Krumsiek</surname><given-names>J</given-names></name><name><surname>P&#x000f6;lsterl</surname><given-names>S</given-names></name><name><surname>Wittmann</surname><given-names>DM</given-names></name><name><surname>Theis</surname><given-names>FJ</given-names></name><article-title>Odefy&#x02013;from discrete to continuous models</article-title><source>BMC Bioinforma</source><year>2010</year><volume>11</volume><fpage>233</fpage><pub-id pub-id-type="doi">10.1186/1471-2105-11-233</pub-id></mixed-citation></ref><ref id="B7"><mixed-citation publication-type="journal"><name><surname>S&#x000e1;nchez-Corrales</surname><given-names>YE</given-names></name><name><surname>Alvarez-Buylla</surname><given-names>ER</given-names></name><name><surname>Mendoza</surname><given-names>L</given-names></name><article-title>The Arabidopsis thaliana flower organ specification gene regulatory network determines a robust differentiation process</article-title><source>J Theor Biol</source><year>2010</year><volume>264</volume><fpage>971</fpage><lpage>983</lpage><pub-id pub-id-type="doi">10.1016/j.jtbi.2010.03.006</pub-id><?supplied-pmid 20303988?><pub-id pub-id-type="pmid">20303988</pub-id></mixed-citation></ref><ref id="B8"><mixed-citation publication-type="journal"><name><surname>Koczan</surname><given-names>D</given-names></name><name><surname>Drynda</surname><given-names>S</given-names></name><name><surname>Hecker</surname><given-names>M</given-names></name><name><surname>Drynda</surname><given-names>A</given-names></name><name><surname>Guthke</surname><given-names>R</given-names></name><name><surname>Kekow</surname><given-names>J</given-names></name><name><surname>Thiesen</surname><given-names>HJ</given-names></name><article-title>Molecular discrimination of responders and nonresponders to anti-TNFalpha therapy in rheumatoid arthritis by etanercept</article-title><source>Arthritis Res Ther</source><year>2008</year><volume>10</volume><fpage>R50</fpage><pub-id pub-id-type="doi">10.1186/ar2419</pub-id><?supplied-pmid 18454843?><pub-id pub-id-type="pmid">18454843</pub-id></mixed-citation></ref><ref id="B9"><mixed-citation publication-type="journal"><name><surname>Naseem</surname><given-names>M</given-names></name><name><surname>Philippi</surname><given-names>N</given-names></name><name><surname>Hussain</surname><given-names>A</given-names></name><name><surname>Wangorsch</surname><given-names>G</given-names></name><name><surname>Ahmed</surname><given-names>N</given-names></name><name><surname>Dandekar</surname><given-names>T</given-names></name><article-title>Integrated systems view on networking by hormones in Arabidopsis immunity reveals multiple crosstalk for cytokinin</article-title><source>Plant Cell</source><year>2012</year><volume>24</volume><fpage>1793</fpage><lpage>1814</lpage><pub-id pub-id-type="doi">10.1105/tpc.112.098335</pub-id><?supplied-pmid 22643121?><pub-id pub-id-type="pmid">22643121</pub-id></mixed-citation></ref><ref id="B10"><mixed-citation publication-type="book"><name><surname>Knuth</surname><given-names>D</given-names></name><article-title>Binary decision diagrams</article-title><source>The Art of Computer Programming. Volume 4A: Combinatorial Algorithm, Part 1</source><year>2011</year><publisher-name>Boston: Addison-Wesley</publisher-name><fpage>202</fpage><lpage>208</lpage></mixed-citation></ref><ref id="B11"><mixed-citation publication-type="journal"><name><surname>Bryant</surname><given-names>RE</given-names></name><article-title>Graph-based algorithms for Boolean function manipulation</article-title><source>IEEE Trans Comput</source><year>1986</year><volume>C-35</volume><fpage>8</fpage></mixed-citation></ref><ref id="B12"><mixed-citation publication-type="journal"><name><surname>Schlatter</surname><given-names>R</given-names></name><name><surname>Philippi</surname><given-names>N</given-names></name><name><surname>Wangorsch</surname><given-names>G</given-names></name><name><surname>Pick</surname><given-names>R</given-names></name><name><surname>Sawodny</surname><given-names>O</given-names></name><name><surname>Borner</surname><given-names>C</given-names></name><name><surname>Timmer</surname><given-names>J</given-names></name><name><surname>Ederer</surname><given-names>M</given-names></name><name><surname>Dandekar</surname><given-names>T</given-names></name><article-title>Integration of Boolean models exemplified on hepatocyte signal transduction</article-title><source>Brief Bioinform</source><year>2012</year><volume>13</volume><issue>3</issue><fpage>365</fpage><lpage>376</lpage><pub-id pub-id-type="doi">10.1093/bib/bbr065</pub-id><?supplied-pmid 22016404?><pub-id pub-id-type="pmid">22016404</pub-id></mixed-citation></ref><ref id="B13"><mixed-citation publication-type="other"><name><surname>Whaley</surname><given-names>J</given-names></name><source>JavaBDD</source><comment><ext-link ext-link-type="uri" xlink:href="http://javabdd.sourceforge.net">http://javabdd.sourceforge.net</ext-link></comment></mixed-citation></ref><ref id="B14"><mixed-citation publication-type="other"><name><surname>Karl</surname><given-names>S</given-names></name><source>Jimena</source><comment><ext-link ext-link-type="uri" xlink:href="http://stefan-karl.de/jimena/">http://stefan-karl.de/jimena/</ext-link></comment></mixed-citation></ref><ref id="B15"><mixed-citation publication-type="journal"><name><surname>Albert</surname><given-names>R</given-names></name><article-title>Scale-free networks in cell biology</article-title><source>J Cell Sci</source><year>2005</year><volume>118</volume><issue>Pt 21</issue><fpage>4947</fpage><lpage>4957</lpage><?supplied-pmid 16254242?><pub-id pub-id-type="pmid">16254242</pub-id></mixed-citation></ref><ref id="B16"><mixed-citation publication-type="journal"><name><surname>Espinosa-Soto</surname><given-names>C</given-names></name><name><surname>Padilla-Longoria</surname><given-names>P</given-names></name><name><surname>Alvarez-Buylla</surname><given-names>E</given-names></name><article-title>A gene regulatory network model for cell-fate determination during Arabidopsis thaliana flower development that is robust and recovers experimental gene expression profiles</article-title><source>Plant Cell</source><year>2004</year><volume>16</volume><fpage>2923</fpage><lpage>2939</lpage><pub-id pub-id-type="doi">10.1105/tpc.104.021725</pub-id><?supplied-pmid 15486106?><pub-id pub-id-type="pmid">15486106</pub-id></mixed-citation></ref><ref id="B17"><mixed-citation publication-type="journal"><name><surname>Koornneef</surname><given-names>M</given-names></name><name><surname>Alonso-Blanco</surname><given-names>C</given-names></name><name><surname>Blankestijn-de Vries</surname><given-names>H</given-names></name><name><surname>Hanhart</surname><given-names>CJ</given-names></name><name><surname>Peters</surname><given-names>AJM</given-names></name><article-title>Genetic interactions among late-flowering mutants of Arabidopsis</article-title><source>Genetics</source><year>1998</year><volume>148</volume><fpage>885</fpage><lpage>892</lpage><pub-id pub-id-type="pmid">9504934</pub-id></mixed-citation></ref><ref id="B18"><mixed-citation publication-type="journal"><name><surname>Isalan</surname><given-names>M</given-names></name><name><surname>Lemerle</surname><given-names>C</given-names></name><name><surname>Michalodimitrakis</surname><given-names>K</given-names></name><name><surname>Horn</surname><given-names>C</given-names></name><name><surname>Beltrao</surname><given-names>P</given-names></name><name><surname>Raineri</surname><given-names>E</given-names></name><name><surname>Carriga-Canut</surname><given-names>M</given-names></name><name><surname>Serrano</surname><given-names>L</given-names></name><article-title>Evolvability and hierarchy in rewired bacterial gene networks</article-title><source>Nature</source><year>2008</year><volume>452</volume><fpage>840</fpage><lpage>845</lpage><pub-id pub-id-type="doi">10.1038/nature06847</pub-id><?supplied-pmid 18421347?><pub-id pub-id-type="pmid">18421347</pub-id></mixed-citation></ref><ref id="B19"><mixed-citation publication-type="journal"><name><surname>Homann</surname><given-names>OR</given-names></name><name><surname>Dea</surname><given-names>J</given-names></name><name><surname>Noble</surname><given-names>S</given-names></name><name><surname>Johnson</surname><given-names>AD</given-names></name><article-title>A phenotypic profile of the candida albicans regulatory network</article-title><source>PLoS Genet</source><year>2009</year><volume>5</volume><fpage>e1000783</fpage><pub-id pub-id-type="doi">10.1371/journal.pgen.1000783</pub-id><?supplied-pmid 20041210?><pub-id pub-id-type="pmid">20041210</pub-id></mixed-citation></ref></ref-list></back></article>